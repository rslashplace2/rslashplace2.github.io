<!DOCTYPE html>
<html lang="en" ontouchstart="if (maincontent.contains(event.target)) event.preventDefault()" ontouchend="event.preventDefault()">
<head>
	<meta charset="UTF-8">
	<script>
		const CHAT_COLOURS = ["lightblue", "navy", "green", "purple", "grey", "brown", "orangered", "gold"]
		const VERIFIED_APP_HASH = "90e58b1f2c5fb98f74962806b85c2d7d3f7b18be8abe7a04f21e939868625357"
		const UNMUTED_SVG = '<path d="M10.543.5a1.12 1.12 0 00-1.182.117L3.789 4.875h-1.8A1.127 1.127 0 00.868 6v8a1.127 1.127 0 001.125 1.125h1.8l5.572 4.258a1.117 1.117 0 00.681.232 1.128 1.128 0 001.127-1.126V1.511A1.119 1.119 0 0010.543.5zm-.624 17.736l-5.708-4.361H2.118v-7.75h2.093l5.708-4.361zM13 3.375v1.25a5.375 5.375 0 010 10.75v1.25a6.625 6.625 0 000-13.25z"></path><path d="M16.125 10A3.129 3.129 0 0013 6.875v1.25a1.875 1.875 0 010 3.75v1.25A3.129 3.129 0 0016.125 10z"></path>'
		const MUTED_SVG = '<path d="M19.442 7.442l-.884-.884L16.5 8.616l-2.058-2.058-.884.884L15.616 9.5l-2.058 2.058.884.884 2.058-2.058 2.058 2.058.884-.884L17.384 9.5l2.058-2.058zM10.543.5a1.12 1.12 0 00-1.182.117L3.789 4.875h-1.8A1.127 1.127 0 00.868 6v8a1.127 1.127 0 001.125 1.125h1.8l5.572 4.258a1.117 1.117 0 00.681.232 1.128 1.128 0 001.127-1.126V1.511A1.119 1.119 0 0010.543.5zm-.624 17.736l-5.708-4.361H2.118v-7.75h2.093l5.708-4.361z"></path>'
		const BADGES = [ "badges/based.svg", "badges/trouble_maker.svg", "badges/veteran.svg", "badges/admin.svg", "badges/moderator.svg", "badges/noob.svg", "badges/script_kiddie.svg", "badges/ethical_botter.svg", "badges/gay.svg", "badges/discord_member.svg", "badges/100_pixels_placed", "badges/1000_pixels_placed", "badges/5000_pixels_placed", "badges/2000_pixels_placed", "badges/100000_pixels_placed", "badges/1000000_pixels_placed" ]
		const DEFAULT_PALETTE_KEYS = "123456789abcdefghijklmnopqrstuvwxyz"

		const AUDIOS = {
			invalid: new Audio("./sounds/invalid.mp3"),
			highlight: new Audio("./sounds/highlight.mp3"),
			selectColour: new Audio("./sounds/select-colour.mp3"),
			closePalette: new Audio("./sounds/close-palette.mp3"),
			cooldownStart: new Audio("./sounds/cooldown-start.mp3"),
			cooldownEnd: new Audio("./sounds/cooldown-end.mp3"),
			bell: new Audio("./sounds/bell.mp3"),
			celebration: new Audio("./sounds/celebration.mp3")
		}

		const EMOJIS = {
			rofl: "ü§£",
			joy: "üòÇ",
			cool: "üòé",
			sunglasses: "üòé",
			heart: "‚ù§Ô∏è",
			moyai: "üóø",
			bruh: "üóø",
			turkey: "üáπüá∑",
			skull: "üíÄ",
			sus: "‡∂û",
			iran: "üáÆüá∑",
			uk: "üá¨üáß",
			usa: "üá∫üá∏",
			america: "üá∫üá∏",
			eyes: "üëÄ",
			fire: "üî•",
			thumbsup: "üëç",
			thumbsdown: "üëé",
			clown: "ü§°",
			facepalm: "ü§¶‚Äç‚ôÇÔ∏è",
			ok: "üëå",
			poop: "üí©",
			rocket: "üöÄ",
			tada: "üéâ",
			celebration: "üéâ",
			moneybag: "üí∞",
			crown: "üëë",
			muscle: "üí™",
			beer: "üç∫",
			pizza: "üçï",
			cookie: "üç™",
			balloon: "üéà",
			gift: "üéÅ",
			star: "‚≠êÔ∏è",
			love: "üòç",
			crying: "üò¢",
			angry: "üò†",
			sleepy: "üò¥",
			nerd: "ü§ì",
			laughing: "üòÜ",
			vomiting: "ü§Æ",
			unicorn: "ü¶Ñ",
			alien: "üëΩ",
			ghost: "üëª",
			skullcrossbones: "‚ò†Ô∏è",
			explosion: "üí•",
			shush: "ü§´",
			deaf: "üßè",
			mew:"ü§´üßè",
			pray: "üôè"
		}

		const EMOJIS_CUSTOM = {
			amogus: '<img src="custom_emojis/amogus.png" height="24">',
			biaoqing: '<img src="custom_emojis/biaoqing.png" height="24">',
			deepfriedh: '<img src="custom_emojis/deepfriedh.png" height="24">',
			edp445: '<img src="custom_emojis/edp445.png" height="24">',
			fan: '<img src="custom_emojis/fan.png" height="24">',
			heavy: '<img src="custom_emojis/heavy.png" height="24">',
			herkul: '<img src="custom_emojis/herkul.png" height="24">',
			kaanozdil: '<img src="custom_emojis/kaanozdil.png" height="24">',
			lowtiergod: '<img src="custom_emojis/lowtiergod.png" height="24">',
			manly: '<img src="custom_emojis/manly.png" height="24">',
			plsaddred: '<img src="custom_emojis/plsaddred.png" height="24">',
			rplace: '<img src="custom_emojis/rplace.png" height="24">',
			rplacediscord: '<img src="custom_emojis/rplacediscord.png" height="24">',
			sonic: '<img src="custom_emojis/sonic.png" height="24">',
			transparent: '<img src="custom_emojis/transparent.png" height="24">',
			trollface: '<img src="custom_emojis/trollface.png" height="24">',
			// Special 'commands'
			help: "<kbd>Chat commands: :vip, :name, :getid</kbd>",
			name: "<kbd>Change your username</kbd>",
			vip: "<kbd>Apply a VIP cooldown code</kbd>",
			lookup: "<kbd>Get the IDs of all players with the given name</kbd>",
			getid: "<kbd>View your own User Id, or provide a name to view a list of online player User Ids</kbd>",
			whoplaced: "<kbd>View details of who placed the current pixel being hoveredd</kbd>"
		}

		// Flag emojis all sourced from openmoji.org, https://www.langoly.com/most-spoken-languages/
		const LANG_INFOS = new Map([
			["en", { name: "English", flag: "https://openmoji.org/data/color/svg/1F1EC-1F1E7.svg" }],
			["zh", { name: "‰∏≠Êñá", flag: "https://openmoji.org/data/color/svg/1F1E8-1F1F3.svg" }],
			["hi", { name: "‡§π‡§ø‡§®‡•ç‡§¶‡•Ä", flag: "https://openmoji.org/data/color/svg/1F1EE-1F1F3.svg" }],
			["es", { name: "Espa√±ol", flag: "https://openmoji.org/data/color/svg/1F1EA-1F1F8.svg" }],
			["fr", { name: "Fran√ßais", flag: "https://openmoji.org/data/color/svg/1F1EB-1F1F7.svg" }],
			["ar", { name: "ÿπÿ±ÿ®Ÿä", flag: "https://openmoji.org/data/color/svg/1F1F8-1F1E6.svg", rtl: true }],
			["bn", { name: "‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ", flag: "https://openmoji.org/data/color/svg/1F1EE-1F1F3.svg" }],
			["ru", { name: "p—É—Å—Å–∫–∏–π", flag: "https://openmoji.org/data/color/svg/1F1F7-1F1FA.svg" }],
			["pt", { name: "Portugu√™s", flag: "https://openmoji.org/data/color/svg/1F1E7-1F1F7.svg" }],
			["ur", { name: "ÿßÿ±ÿØŸà", flag: "https://openmoji.org/data/color/svg/1F1F5-1F1F0.svg", rtl: true }],
			["de", { name: "Deutsch", flag: "https://openmoji.org/data/color/svg/1F1E9-1F1EA.svg" }],
			["jp", { name: "Êó•Êú¨Ë™û", flag: "https://openmoji.org/data/color/svg/1F1EF-1F1F5.svg" }],
			["tr", { name: "T√ºrk√ße", flag: "https://openmoji.org/data/color/svg/1F1F9-1F1F7.svg" }],
			["vi", { name: "Ti·∫øng Vi·ªát", flag: "https://openmoji.org/data/color/svg/1F1FB-1F1F3.svg" }],
			["ko", { name: "ÌïúÍµ≠Ïù∏", flag: "https://openmoji.org/data/color/svg/1F1F0-1F1F7.svg" }],
			["it", { name: "Italiana", flag: "https://openmoji.org/data/color/svg/1F1EE-1F1F9.svg" }],
			["fa", { name: "ŸÅÿßÿ±ÿ≥€å", flag: "https://openmoji.org/data/color/svg/1F1EE-1F1F7.svg", rtl: true }],
			["sr", { name: "–°—Ä–ø—Å–∫–∏", flag: "https://openmoji.org/data/color/svg/1F1E6-1F1F1.svg"}],
			["az", { name: "Az…ôrbaycan", flag: "https://openmoji.org/data/color/svg/1F1E6-1F1FF.svg", rtl: true }],
		])

		const DEFAULT_THEMES = new Map([
			[ "r/place 2022", { id: "r/place 2022", css: "rplace-2022.css", cssVersion: "11", pixelselect: "svg/pixel-select-2022.svg" }],
			[ "r/place 2023", { id: "r/place 2023", css: "rplace-2023.css", cssVersion: "11", pixelselect: "svg/pixel-select-2023.svg" }],
		])

		const ADS = [
			{ url: "mailto:admin@rplace.live", banners: { en: "images/default-ad.png" } },
			{ url: "https://t.me/rplacelive", banners: { en: "images/telegram-ad.png" } },
			{ url: "https://discord.gg/4XnZ9WGux2", banners: { en: "images/discord-ad.png" } },
			{ url: "https://arbitrum.life", banners: { en: "https://avatars.githubusercontent.com/u/131141781" } },
		]

		const PUNISHMENT_STATE = {
			mute: 0,
			ban: 1,
			appealRejected: 2,
		}

		const MAX_CHANNEL_MESSAGES = 100
	</script>
	<script>
		if(!("subtle" in (window.crypto || {}))) location.protocol = "https:"
		const automated = navigator.webdriver
		// csrfstate not used at the moment, may be later to encode some extra info for client
		let params = new URLSearchParams(location.search)
		let csrfState = params.get("state"),
			redditOauthCode = params.get("code")
			boardParam = params.get("board"),
			serverParam = params.get("server")

		if (boardParam && serverParam) {
			if (localStorage.server != serverParam || localStorage.board != boardParam) {
				localStorage.server = serverParam
				localStorage.board = boardParam
				history.pushState(null, '', location.origin)
				window.location.reload()
			}
		}

		// Register PWA Service worker
		if ("serviceWorker" in navigator) {
			navigator.serviceWorker.register("./sw.js?v=2.0")
		}
		const intIdPositions = new Map() // position : intId
		const intIdNames = new Map() // intId : name
		let account = null
		let intId = null
		let chatName = null
		let fetchLinkKey = null // function injected by wscapsule
		let setName = null // function injected by wscapsule
		let requestPixelPlacers = null // function injected by wscapsule
		let requestLoadChannelPrevious = null // function injected by wscapsule
		let canvasLocked = false // Server will tell us this
		let includesPlacer = false // Server will tell us this

		const wscapsule = ((send, addEventListener, call) => {
			let focused = true
			call(addEventListener, window, "blur", () => focused = false)
			call(addEventListener, window, "focus", () => focused = true)

			let authSocket = {} //new WebSocket("wss://server.poemanthology.org/auth")
			// HACK: Until enough clients are using the new server 
			if (localStorage.server?.startsWith("wss://server.rplace.tk")) {
				delete localStorage.server
			}

			let svUri = localStorage.server || DEFAULT_SERVER
			if (localStorage.vip) {
				if (!svUri.endsWith("/")) svUri += "/"
				svUri += localStorage.vip
			}
			let ws = new WebSocket(svUri)
			delete WebSocket

			function chatReport(messageId, senderId) {
				const reason = prompt("Enter the reason for why you are reporting this message (max 280 chars)\n\n" +
					`Additional info:\nMessage ID: ${messageId}\nSender ID: ${senderId}\n`)
				if (!reason || !reason.trim()) {
					return
				}
				const reportBuffer = encoder.encode("XXXXX" + reason)
				reportBuffer[0] = 14
				reportBuffer[1] = messageId >> 24
				reportBuffer[2] = messageId >> 16
				reportBuffer[3] = messageId >> 8
				reportBuffer[4] = messageId & 255
				call(send, ws, reportBuffer)
				alert("Report sent!\nIn the meantime you can block this user by 'right clicking / press hold on the message' > 'block'")
			}

			function createLiveChatMessage(messageId, txt, senderId, name, sendDate, repliesTo = null) {
				let newMessage = document.createElement("div")
				newMessage.messageId = messageId
				newMessage.name = name
				newMessage.originalContent = txt

				// Sanitise regex
				txt = sanitise(txt)
				// Simple markdown parse regexes
				txt = markdownParse(txt)
				// Custom emoji regex
				txt = txt.replaceAll(/:([a-z-_]{0,16}):/g, (full, source) => {
					// If this emoji is the only thing in the message we can make it big!
					if (txt.match(source).length == 1 && !txt.replace(full, "").trim()) {
						return `<img src="custom_emojis/${source}.png" alt=":${source}:" title=":${source}:" width="48" height="48">`
					}

					// Else smaller and inline with the rest of the message
					return `<img src="custom_emojis/${source}.png" alt=":${source}:" title=":${source}:" width="16" height="16">`
				})
				// Coordinate to clickable link regex
				txt = txt.replaceAll(/([0-9]+),\s*([0-9]+)/g, (element) => {
					let px = parseInt(element.split(",")[0].trim())
					let py = parseInt(element.split(",")[1].trim())
					if (px != NaN && py != NaN) {
						return `<a href="#" onclick="event.preventDefault();x=${px};y=${py};pos();">${px},${py}</a>`
					}
				})

				let namePart = document.createElement("span")
				if (messageId === 0) {
					namePart.classList.add("rainbow-glow")
				}
				else {
					namePart.style.color = CHAT_COLOURS[hash("" + senderId) & 7]
				}
				namePart.title = (new Date(sendDate * 1000)).toLocaleString()
				namePart.textContent = `[${name || ("#" + senderId)}] `
				let txtPart = document.createElement("span")
				txtPart.innerHTML = txt

				if (repliesTo != null) {
					let replyingMessage = null
					for (let message of cMessages[currentChannel]) {
						if (message.messageId == repliesTo) {
							replyingMessage = message
							break
						}
					}
					if (replyingMessage == null) {
						replyingMessage = {
							name: "[?????]",
							originalContent: translate("messageCouldntBeLoaded"),
							fake: true
						}
					}

					let repliesPart = document.createElement("p")
					if (!replyingMessage.fake) {
						repliesPart.onclick = function() {
							let height = 0
							for (let message of cMessages[currentChannel]) {
								if (message == replyingMessage) break
								height += message.offsetHeight
							}

							replyingMessage.setAttribute("highlight", "true")
							setTimeout(() => {
								replyingMessage.removeAttribute("highlight")
							}, 500)

							chatMessages.scroll({ top: height, left: 0, behavior: "smooth" })
						}
					}
					repliesPart.innerText = `‚Ü™Ô∏è ${replyingMessage.name} ${replyingMessage.originalContent}`
					newMessage.appendChild(repliesPart)
				}

				newMessage.appendChild(namePart)
				newMessage.appendChild(txtPart)
				if (messageId > 0) { // Disable interactivity for system messages
					namePart.onclick = (e) => chatMentionUser(senderId)
					newMessage.oncontextmenu = (e) => onChatContext(e, senderId, messageId)

					let actionsPart = document.createElement("div")
					let replyBtn = document.createElement("img")
					replyBtn.onclick = function(e) { chatReply(messageId, senderId) }
					replyBtn.title = translate("replyTo")
					replyBtn.tabIndex = "0"
					replyBtn.src = "svg/reply-action.svg"
					actionsPart.appendChild(replyBtn)

					let reportBtn = document.createElement("img")
					reportBtn.onclick = function(e) { chatReport(messageId, senderId) }
					reportBtn.title = translate("report")
					replyBtn.tabIndex = "0"
					reportBtn.src = "svg/report-action.svg"
					actionsPart.appendChild(reportBtn)

					if (localStorage.vip?.startsWith("!")) {
						let moderateBtn = document.createElement("img")
						moderateBtn.onclick = function(e) { chatModerate("delete", senderId, messageId, newMessage) }
						replyBtn.title = "Moderation options"
						replyBtn.tabIndex = "0"
						moderateBtn.src = "svg/moderate-action.svg"
						actionsPart.appendChild(moderateBtn)
					}
					newMessage.appendChild(actionsPart)
				}

				return newMessage
			}

			authSocket.binaryType = "arraybuffer"
			authSocket.onopen = function() {
				// Then we know we have been redirected from a reddit oauth, and will now authenticate with auth server
				if (redditOauthCode) {
					let cb = encoder.encode("X" + redditOauthCode)
					cb[0] = 9 // ClientPackets.RedditCreateAccount
					call(send, authSocket, cb)
				}
				else if (localStorage.refreshToken) {
					let ab = encoder.encode("X" + localStorage.refreshToken)
					ab[0] = 10 // ClientPackets.RedditAuthenticate
					call(send, authSocket, ab)
				}
				else if (localStorage.accountToken) {
					let ab = encoder.encode("X" + localStorage.accountToken)
					ab[0] = 5 // ClientPackets.Authenticate
					call(send, authSocket, ab)
				}
			}
			authSocket.onmessage = async function({data}) {
				data = new DataView(data)

				switch (data.getUint8(0)) {
				case 0: { // ServerPackets.Fail
					console.error(decoder.decode(data.buffer.slice(1)))
					break
				}
				case 1: {
					loginPanel.style.display = "flex"

					account = JSON.parse(decoder.decode(data.buffer.slice(1)))
					profileName2.textContent = profileName.textContent = account.Username
					// We use discord ID so that we can directly link their discord profile. Thanks https://discord.name/ for the api :).
					if (account.DiscordSnowflake) {
						let discordUser = await (await fetch("https://discord-lookup-api.herokuapp.com/user/" + account.DiscordSnowflake)).json()
						if (discordUser && discordUser.success) {
							profileDiscordIcon.src = discordUser.data.avatar || "images/discord.png"
							profileDiscord.textContent = discordUser.data.username
							profileDiscord.href = "https://discord.com/users/" + account.DiscordSnowflake
						}
					}
					if (account.TwitterHandle) {
						profileTwitter.textContent = account.TwitterHandle
						profileTwitter.href = "https://twitter.com/" + account.TwitterHandle
					}
					// We can also scrape their snoo/user icon using reddit. Thanks reddit!
					if (account.RedditHandle) {
						profileReddit.textContent = account.RedditHandle
						profileReddit.href = "https://www.reddit.com/user/" + account.RedditHandle.replaceAll("/u/", "")
						let redditUser = await (await fetch("https://www.reddit.com/user/"+ account.RedditHandle +"/about.json")).json()
						if (redditUser && !redditUser.error) {
							profileRedditIcon.src = redditUser.data.snoovatar_img || redditUser.data.icon_img || "images/reddit.png"
						}
					}
					profilePixels.textContent = account.PixelsPlaced
					profileJoin.textContent = new Date(account.JoinDate).toLocaleString()
					for (let i of account.Badges) {
						let badgeImg = document.createElement("img")
						badgeImg.src = BADGES[i]
						badgeImg.style.width = "16px"
						badgeImg.title = BADGES[i][7].toUpperCase() + BADGES[i].replace("_", "").slice(8, BADGES[i].length - 4)
						profileBadges.appendChild(badgeImg)
					}
					accountTier.textContent = account.AccountTier
					accountName.textContent = account.Username
					let censoredSection = account.Email.slice(4, account.Email.indexOf("@"))
					accountEmail.textContent = account.Email.replace(censoredSection, "*".repeat(censoredSection.length))
					break
				}
				case 5: { // ServerPackets.AccountToken
					localStorage.accountToken = decoder.decode(data.buffer.slice(1))
					console.log("Account authentication success")
					call(send, authSocket, new Uint8Array([4])) // ClientPackets.AccountInfo
					break
				}
				case 7: { // ServerPackets.RedditRefreshToken
					localStorage.refreshToken = decoder.decode(data.buffer.slice(1))
					console.log("Reddit OAuth success")
					call(send, authSocket, new Uint8Array([4])) // ClientPackets.AccountInfo
					// Clean up our params to avoid reauthenticating on reload
					let params = new URLSearchParams(location.search)
					params.delete("code")
					history.pushState(null, "", location.origin + "/" + params.toString())
					break
				}
			}
			}
			authSocket.onclose = console.error
			ws.onopen = function(e) {
				initialConnect = true
				if (automated) {
					console.error("Unsupported environment. Connection can not be guarenteed")
					function reportUsage() {
						const activityBuffer = encoder.encode(`\x1eWindow outer width: ${window.outerWidth}\nWindow inner width: ${window.innerWidth}\n` +
							`Window outer height: ${window.outerHeight}\nWindow inner height: ${window.innerHeight}\nLast mouse move: ${new Date(lastMouseMove).toISOString()}\n` +
							`Mouse X (mx): ${mx}\nMouse Y (my): ${my}\nLocal storage: ${JSON.stringify(localStorage, null, 4)}`)
						call(send, ws, activityBuffer)
					}
					setInterval(reportUsage, 3e5) // 5 mins
					reportUsage()
				}
			}
			ws.onmessage = async function({data}) {
				delete sessionStorage.err
				data = new DataView(await data.arrayBuffer())

				switch (data.getUint8(0)) {
				case 0: {
					let pi = 1
					const paletteLength = data.getUint8(pi++)
					PALETTE = [...new Uint32Array(data.buffer.slice(pi, pi += paletteLength * 4))]
					PALETTE_USABLE_REGION.start = data.getUint8(pi++)
					PALETTE_USABLE_REGION.end = data.getUint8(pi++)
					generatePalette()
					const binds = (localStorage.paletteKeys || DEFAULT_PALETTE_KEYS)
					generateIndicators(binds)
					// Board might have already been drawn with old palette so we need to draw it again
					if (boardAlreadyRendered === true) {
						renderAll()
					}
					break
				}
				case 1: {
					CD = data.getUint32(1) * 1000 // Current cooldown
					COOLDOWN = data.getUint32(5)

					// New server packs canvas width and height in code 1, making it 17
					if (data.byteLength == 17) {
						let width = data.getUint32(9)
						let height = data.getUint32(13)
						setSize(width, height)
						runLengthDecodeBoard(await preloadedBoard, width * height)
						hideLoadingScreen()
					}
					break
				}
				case 2: {
					// Old server "changes" packet - preloadedBoard = http board, data = changes
					runLengthChanges(data, await preloadedBoard)
					hideLoadingScreen()
					break
				}
				case 3: { // Online
					online = data.getUint16(1)
					onlineCounter.textContent = online
					sendPostsFrameMessage("onlineCounter", online)
					break
				}
				case 5: { // Pixel with included placer
					let i = 1
					while (i < data.byteLength) {
						let position = data.getUint32(i); i += 4
						seti(position, data.getUint8(i)); i += 1
						intIdPositions.set(position, data.getUint32(i)); i += 4
					}
					break
				}
				case 6: { // Pixel without included placer
					let i = 0
					while (i < data.byteLength - 2) {
						seti(data.getUint32(i += 1), data.getUint8(i += 4))
					}
					break
				}
				case 7: { // Rejected pixel
					CD = data.getUint32(1) * 1000
					seti(data.getUint32(5), data.getUint8(9))
					break
				}
				case 8: { // Canvas restriction
					canvasLocked = !!data.getUint8(1)
					canvasLock.style.display = canvasLocked ? "flex" : "none"
					const reason = decoder.decode(data.buffer.slice(2))
					if (reason) { // TODO: Maybe find a more pretty elegant solution
						alert(reason)
					}
					break
				}
				case 9: { // Placer info region
					let i = data.getUint32(1)
					const regionWidth = data.getUint8(5)
					const regionHeight = data.getUint8(6)
					 
					let dataI = 7
					while (dataI < data.byteLength) {
						for (let xi = i; xi < i + regionWidth; xi++) {
							const placerIntId = data.getUint32(dataI)
							//  TODO: HACK: until we can debug this mess
							if (placerIntId === 0) {
								const dumpPropName = "_placerData" + Date.now()
								window[dumpPropName] = data
								return console.warn("Possibly wrong placer detected, check", dumpPropName)
							}
							if (placerIntId !== 0xFFFFFFFF) {
								intIdPositions.set(xi, placerIntId)
							}
							dataI += 4
						}
						i += WIDTH
					}
					break
				}
				case 11: { // Player int ID // TODO: Integrate into packet 1
					intId = data.getUint32(1)
					break
				}
				case 12: { // Name info
					for (let i = 1; i < data.byteLength;) {
						let pIntId = data.getUint32(i); i += 4
						let pNameLen = data.getUint8(i); i++
						let pName = decoder.decode(data.buffer.slice(i, (i += pNameLen)))

						intIdNames.set(pIntId, pName)
						// Occurs either if server has sent us name it has remembered from a previous session,
						// or we have just sent server packet 12 name update, and it is sending us back our name
						if (pIntId == intId) {
							chatName = pName
							namePanel.style.visibility = "hidden"
						}
					}
					break
				}
				case 13: { // Live chat history
					let i = 1
					let fromMessageId = data.getUint32(i); i += 4
					let count = data.getUint8(i) & 127
					let before = data.getUint8(i) >> 7; i++
					let channelLen = data.getUint8(i++)
					let channel = decoder.decode(data.buffer.slice(i, (i += channelLen)))

					if (channel !== currentChannel) return
					while (i < data.byteLength) {
						let offset = i
						const messageLength = data.getUint16(offset); offset += 2
						const messageId = data.getUint32(offset); offset += 4
						const txtLength = data.getUint16(offset); offset += 2
						let txt = decoder.decode(data.buffer.slice(offset, (offset += txtLength)))
						const intId = data.getUint32(offset); offset += 4 // sender int ID
						const name = intIdNames.get(intId)

						let sendDate = data.getUint32(offset); offset += 4
						let reactionsL = data.getUint8(offset); offset++ // TODO: Reactions
						// let reactions = .. TODO: we worry about this later
						let channelL = data.getUint8(offset); offset++
						let channel = decoder.decode(data.buffer.slice(offset, (offset += channelL)))
						let repliesTo = null
						if (messageLength - (offset - i) == 4) {
							repliesTo = data.getUint32(offset); offset += 4
						}

						// TODO: We will worry about after when we get dynamic message loading
						const newMessage = createLiveChatMessage(messageId, txt, intId, name, sendDate, repliesTo)
						if (before) {
							let scrollBefore = chatMessages.scrollTop
							chatMessages.prepend(newMessage)
							chatMessages.scrollTop = scrollBefore + newMessage.offsetHeight
						}
						i = offset
					}
					// chatPrevious button height (looks more seamless if the last of the
					// loaded previous messages can be seen in place of the previous button
					chatMessages.scrollTop -= 18
					// Prevent site from spam loading chat messages when already at scroll top until it
					// received the last lot
					chatPreviousLoadDebounce = false
					break
				}
				case 14: { // Moderation
					let i = 1
					let state = data.getUint8(i++)
					let startDate = data.getUint32(i) * 1000; i += 4
					let endDate = data.getUint32(i) * 1000; i+= 4
					let reasonLen = data.getUint8(i++)
					let reason = decoder.decode(data.buffer.slice(i, i + reasonLen)); i += reasonLen
					let appealLen = data.getUint8(i++)
					let appeal = decoder.decode(data.buffer.slice(i, i + appealLen)); i += appealLen

					let punishInfo = "Started on: " + new Date(startDate).toLocaleString() + "\n" +
						"Ends on: " + new Date(endDate).toLocaleString() + "\n" +
						"Reason: " + reason + "\n" +
						"Appeal: " + (appeal || "N/A")
					chatPunishInfo.textContent = punishInfo

					messageInput.disabled = true
					chatPunishPanel.removeAttribute("closed")
					if (state == PUNISHMENT_STATE.mute) {
						chatPunishNote.innerText = "You have been muted. You can not send messages in live chat."
					}
					else if (state == PUNISHMENT_STATE.ban) {
						canvasLock.style.display = "flex"
						canvasLocked = true
						chatPunishNote.innerText = "You have been banned from placing on the canvas or sending messages in live chat."
					}
					break
				}
				case 15: { // Chat
					let repliesTo = null

					let offset = 1
					const msgType = data.getUint8(offset); offset++
					const messageId = data.getUint32(offset); offset += 4
					const txtLength = data.getUint16(offset); offset += 2
					let txt = decoder.decode(data.buffer.slice(offset, (offset += txtLength)))
					const senderIntId = data.getUint32(offset); offset += 4 // sender int ID
					const name = intIdNames.get(senderIntId)

					if (msgType == 0) { // live
						let sendDate = data.getUint32(offset); offset += 4
						let reactionsL = data.getUint8(offset); offset++ // TODO: Reactions
						// let reactions = .. TODO: we worry about this later
						let channelL = data.getUint8(offset); offset++
						let channel = decoder.decode(data.buffer.slice(offset, (offset += channelL)))
						if (data.byteLength - offset >= 4) {
							repliesTo = data.getUint32(offset)
						}
						if (!(channel in cMessages)) return

						const newMessage = createLiveChatMessage(messageId, txt, senderIntId, name, sendDate, repliesTo)
						if (senderIntId !== 0 && blockedUsers.includes(senderIntId)) {
							newMessage.style.color = "transparent"
							newMessage.style.textShadow = "0px 0px 6px black"
						}
						if (txt.includes("@" + chatName) || txt.includes("@#" + intId) || txt.includes("@everyone")) {
							newMessage.setAttribute("mention", "true")
							if (currentChannel == channel) AUDIOS.closePalette.run()
						}
						const atScrollBottom = chatMessages.scrollTop + chatMessages.offsetHeight + 16 >= chatMessages.scrollHeight

						// Insert the message into the channel
						cMessages[channel].push(newMessage)
						if (cMessages[channel].length > MAX_CHANNEL_MESSAGES) {
							cMessages[channel].shift()
						}
						if (channel == currentChannel) {
							if (chatMessages.children.length > MAX_CHANNEL_MESSAGES) chatMessages.children[0].remove()
							chatMessages.insertAdjacentElement("beforeEnd", newMessage)
						}

						// If at scroll bottom (we scroll down when new chat messages come)
						if (atScrollBottom) {
							chatMessages.scrollTo(0, chatMessages.scrollHeight)
						}
					}
					else { // place
						if (!placeChat) return
						let msgPos = data.getUint32(offset)
						txt = txt.substring(0, 56)

						const placeMessage = document.createElement("placechat")
						placeMessage.innerHTML = `<span title="${(new Date()).toLocaleString()}" style="color: ${CHAT_COLOURS[hash("" + senderIntId) & 7]};">[${name}]</span><span>${txt}</span>`
						placeMessage.style.left = (msgPos % WIDTH) + "px"
						placeMessage.style.top = (Math.floor(msgPos / WIDTH) + 0.5) + "px"
						canvparent2.appendChild(placeMessage)

						//Remove message after given time.
						setTimeout(() => {
							canvparent2.removeChild(placeMessage)
						}, localStorage.placeChatTime || 7e3)
					}
					break
				}
				case 16: { // Captcha success
					captchaPopup.style.display = "none"
					break
				}
				case 17: {// Live chat delete
					const messageId = data.getUint32(1)
					for (let channel of Object.values(cMessages)) {
						for (let messageEl of channel) {
							if (messageEl.messageId !== messageId) continue
							channel.splice(channel.indexOf(messageEl), 1)
							messageEl.remove()
						}
					}
					break
				}
				case 18: { // Text capcha
					let textsSize = data.getUint8(1)
					let texts = decoder.decode(new Uint8Array(data.buffer).slice(2, textsSize + 2)).split("\n")
					let imageData = new Uint8Array(data.buffer).slice(2 + textsSize)
					captchaOptions.innerHTML = ""

					for (let text of texts) {
						let button = document.createElement("button")
						button.textContent = text
						captchaOptions.appendChild(button)

						button.addEventListener("click", (event) => {
							call(send, ws, encoder.encode("\x10" + event.target.textContent))
							captchaOptions.style.pointerEvents = "none"
						})
					}
					captchaPopup.style.display = "flex"
					captchaOptions.style.pointerEvents = "all"
					const imageBlob = new Blob([imageData], { type: "image/png" })
					if (webGLSupported) {
						updateImgCaptchaCanvas(imageBlob)
					}
					else {
						updateImgCaptchaCanvasFallback(imageBlob)
					}
					break
				}
				case 19: { // Math captcha
					console.error("Math captcha not yet supported. Ignoring.")
					break
				}
				case 20: { // Emoji captcha
					let emojisSize = data.getUint8(1)
					let emojis = decoder.decode(new Uint8Array(data.buffer).slice(2, emojisSize + 2)).split("\n")
					let imageData = new Uint8Array(data.buffer).slice(2 + emojisSize)
					captchaOptions.innerHTML = ""

					let captchaSubmitted = false
					for (let emoji of emojis) {
						let buttonParent = document.createElement("button")
						buttonParent.classList.add("captcha-options-button")
						buttonParent.setAttribute("value", emoji)
						let emojiImg = document.createElement("img")
						emojiImg.src = `./tweemoji/${emoji.codePointAt(0).toString(16)}.png`
						emojiImg.alt = emoji
						emojiImg.title = emoji
						emojiImg.fetchPriority = "high"
						emojiImg.addEventListener("load", (event) => {
							buttonParent.classList.add("loaded")
						})
						buttonParent.appendChild(emojiImg)
						captchaOptions.appendChild(buttonParent)

						function submitCaptcha(event) {
							if (captchaSubmitted || !emoji) {
								return console.error("Could not send captcha response. No emoji?")
							}
							captchaSubmitted = true
							call(send, ws, encoder.encode("\x10" + emoji))
							captchaOptions.style.pointerEvents = "none"
							clearCaptchaCanvas()
						}
						buttonParent.addEventListener("click", submitCaptcha)
						emojiImg.addEventListener("click", submitCaptcha)
						buttonParent.addEventListener("touchend", submitCaptcha)
						emojiImg.addEventListener("touchend", submitCaptcha)
					}

					captchaPopup.style.display = "flex"
					captchaOptions.style.pointerEvents = "all"
					const imageBlob = new Blob([imageData], { type: "image/png" })
					if (webGLSupported) {
						updateImgCaptchaCanvas(imageBlob)
					}
					else {
						updateImgCaptchaCanvasFallback(imageBlob)
					}
					break
				}
				case 21: {
					let a=data.getUint32(1),b=5+a,c=data.buffer.slice(5,5+a),f=new Uint8Array(9),u=new DataView(f.buffer)
					;window.challengeData=new Uint8Array(data.buffer.slice(b));let d=await Object.getPrototypeOf(async function(){}).constructor(atob(decoder.decode(c)))()
					;delete window.challengeData;u.setUint8(0,21);u.setBigInt64(1,d);call(send,ws,u.buffer);
					break
				}
				case 23: { // Turnstile
					const siteKey = decoder.decode(data.buffer.slice(1))
					const siteVariant = document.documentElement.dataset.variant
					const turnstileTheme = siteVariant === "dark" ? "dark" : "light"

					turnstileMenu.setAttribute("opened", true)
					turnstile.ready(function () {
						turnstile.render("#turnstileContainer", {
							sitekey: siteKey,
							theme: turnstileTheme,
							language: lang,
							callback: function(token) {
								call(send, ws, encoder.encode("\x17" + token))
							},
						})
					})
					break
				}
				case 24: { // Turnstile success
					turnstileMenu.removeAttribute("opened")
					break
				}
				case 110: {
					const requestsLength = linkKeyRequests.length
					if (!requestsLength) {
						console.error("Could not resolve link key, no existing link key requests could be found")
						break
					}
					const instanceId = data.getUint32(1)
					const linkKey = decoder.decode(data.buffer.slice(5))
					linkKeyRequests[requestsLength - 1].resolve({ linkKey, instanceId })
					break
				}
				}
			}
			ws.onclose = function(e) {
				//Something went wrong...
				CD = null
				console.error(e)
				if (e.code == 1006 && !sessionStorage.err) {
					sessionStorage.err = "1"
					window.location.reload(true)
				}

				loadingScreen.children[0].src = "images/rplace-offline.png"
				showLoadingScreen()
			}

			let linkKeyRequests = []
			async function _fetchLinkKey() {
				linkKeyRequest = new PublicPromise()
				linkKeyRequests.push(linkKeyRequest)
				call(send, ws, new Uint8Array([110]))
				const linkInfo = await linkKeyRequest.promise
				return linkInfo
			}
			fetchLinkKey = _fetchLinkKey
			window["fetchLinkKey"] = _fetchLinkKey

			function _setName(uname) {
				if (uname.length > 16) return
				uname ||= "anon"

				const nameBuf = encoder.encode("\x0C" + uname)
				call(send, ws, nameBuf)
			}
			setName = _setName

			// Requests all the pixel placers for a given region from the server to be loaded into 
			function _requestPixelPlacers(x, y, width, height) {
				if (ws.readyState !== ws.OPEN) {
					throw new Error("Could not request pixel placers, websocket state is not open")
				}
				const placerInfoBuf = new DataView(new Uint8Array(7).buffer)
				placerInfoBuf.setUint8(0, 9)
				placerInfoBuf.setUint32(1, x + y * WIDTH)
				placerInfoBuf.setUint8(5, width)
				placerInfoBuf.setUint8(6, height)
				call(send, ws, placerInfoBuf)
			}
			requestPixelPlacers = _requestPixelPlacers

			function put() {
				// If CD is null but we have already made that initial connection, we have likely ghost disconnected from the WS
				if (!focused || !initialConnect || (CD === null && initialConnect) || CD > Date.now()) {
					return
				}

				pok.classList.remove("enabled")
				set(Math.floor(x), Math.floor(y), PEN)
				canvselect.style.background = ""
				canvselect.children[0].style.display = "block"
				canvselect.style.outline = ""
				canvselect.style.boxShadow = ""
				palette.style.transform = "translateY(100%)"
				AUDIOS.cooldownStart.run()
				CD = Date.now() + (localStorage.vip ? (localStorage.vip[0] == '!' ? 0 : COOLDOWN / 2) : COOLDOWN)

				const pixelView = new DataView(new Uint8Array(6).buffer)
				pixelView.setUint8(0, 4)
				pixelView.setUint32(1, Math.floor(x) + Math.floor(y) * WIDTH)
				pixelView.setUint8(5, PEN)

				if (!mobile) {
					colours.children[PEN].classList.remove("sel")
					PEN = -1
				}

				localStorage.placed = (localStorage.placed >>> 0) + 1
				call(send, ws, pixelView)
			}
			let pok = document.getElementById("pok")

			function onOkClicked(e) {
				if (!e.isTrusted) return
				if (pok.classList.contains("enabled")) put()
				hideIndicators()
			}
			call(addEventListener, pok, "click", onOkClicked)

			function sendLiveChatMsg(message) {
				if (message.startsWith(":name")) {
					namePanel.style.visibility = "visible"
					nameInput.value = message.slice(5).trim()
					return
				}
				else if (message.startsWith(":vip")) {
					let key = message.slice(4).trim()
					localStorage.vip = key
					window.location.reload(true)
					return
				}
				else if (localStorage.vip && message.includes(localStorage.vip)) {
					alert("Can't send VIP key in chat. Use ':vip yourvipkeyhere' to apply a VIP key")
					return
				}
				else if (message.startsWith(":getid")) {
					let targetName = message.slice(6).trim().toLowerCase()
					if (!targetName) {
						alert("Your User ID is: #" + intId)
					}
					else {
						let foundUsers = `Found Users with name '${targetName}:'\n`
						for (let pair of intIdNames) {
							if (pair[1] === targetName) {
								foundUsers += `${pair[1]}, #${pair[0]}\n`
							}
						}

						alert(foundUsers)
					}
					return
				}
				else if (message.startsWith(":whoplaced")) {
					let id = intIdPositions.get(Math.floor(x) + Math.floor(y) * WIDTH)
					if (id === undefined) {
						alert("Could not find details of who placed pixel at current location...")
						return
					}
					let name = intIdNames.get(id)
					alert(`Details of who placed at ${Math.floor(x)}, ${Math.floor(y)
						}:\nName: ${name || 'anon'
						}\nUser ID: #${id}`)
					return
				}
				else if (message.startsWith(":help")) {
					return
				}

				const encodedChannel = encoder.encode(currentChannel)
				const encodedMsg = encoder.encode(message)

				let msgArray = new Uint8Array(1 + 1 + 2 + encodedMsg.byteLength + 1
					+ encodedChannel.byteLength + (currentReply ? 4 : 0))
				let msgView = new DataView(msgArray.buffer)

				let offset = 0;
				msgView.setUint8(offset++, 15)
				msgView.setUint8(offset++, 0) // type
				msgView.setUint16(offset, encodedMsg.byteLength) // msg length
				offset += 2
				msgArray.set(encodedMsg, offset)
				offset += encodedMsg.byteLength
				msgView.setUint8(offset, encodedChannel.byteLength)
				offset += 1
				msgArray.set(encodedChannel, offset)
				offset += encodedChannel.byteLength
				if (currentReply != null) {
					msgView.setUint32(offset, currentReply)
				}

				chatCancelReplies()
				call(send, ws, msgView)
			}

			function sendPlaceMsg(message) { // message put on the canvas
				const encodedMsg = encoder.encode(message)

				let msgArray = new Uint8Array(1 + 1 + 2 + encodedMsg.byteLength + 4)
				let msgView = new DataView(msgArray.buffer)
				let offset = 0
				msgView.setUint8(offset++, 15)
				msgView.setUint8(offset++, 1) // type
				msgView.setUint16(offset, encodedMsg.byteLength)
				offset += 2
				msgArray.set(encodedMsg, offset)
				offset += encodedMsg.byteLength
				msgView.setUint32(offset, Math.floor(y) * WIDTH + Math.floor(x))

				call(send, ws, msgView)
			}

			messageTypePanel.children[0].onclick = e => {
				sendPlaceMsg(messageInput.value)
				messageInput.value = ""
			}

			messageTypePanel.children[1].onclick = e => {
				sendLiveChatMsg(messageInput.value)
				messageInput.value = ""
			}

			messageInput.onkeydown = e => {
				if (!e.isTrusted) return
				if (e.key == "Enter" && !e.shiftKey) {
					// ctrl + enter send as place chat, enter send as normal live chat
					if (e.ctrlKey) sendPlaceMsg(messageInput.value)
					else sendLiveChatMsg(messageInput.value)
					e.preventDefault()
					messageInput.value = ""
					updateMessageInputHeight()
				}
			}

			call(addEventListener, document.body, "keydown", function(e) {
				if (!e.isTrusted) return

				//"Shift+O" to open overlay menu
				if (e.key === "O" && e.shiftKey && !("value" in document.activeElement)) {
					e.preventDefault()
					overlayMenu.toggleAttribute("opened")
				}
				else if (e.key === "/" && !("value" in document.activeElement)) {
					e.preventDefault()
					openChatPanel()
					messageInput.focus()
				}
				else if (e.key === "Escape") {
					// TODO: Not optimal, but it works for now
					e.preventDefault()
					modal.style.display = "flex"
					bg.style.display = "block"
				}
				else if (e.key === "=" || e.key == "+") {
					e.preventDefault()
					z += 0.02
					pos()
				}
				else if (e.key === "-") {
					e.preventDefault()
					z -= 0.02
					pos()
				}

				// Move around with arrow keys
				let moveEaseI = 10
				let repeatFunc = setInterval(function() {
					// We use 55 because: 10/55+9/55+8/55+7/55+6/55+5/55+4/55+3/55+2/55+1/55 == 1
					switch (e.keyCode) {
					case 37:
						x -= moveEaseI / 55
						arrowkeyDown.right = true
						break //right
					case 38:
						y -= moveEaseI / 55
						arrowkeyDown.up = true
						break //up
					case 39:
						x += moveEaseI / 55
						arrowkeyDown.left = true
						break //left
					case 40:
						y += moveEaseI / 55
						arrowkeyDown.down = true
						break //down
					}
					pos()
					moveEaseI--
					if (moveEaseI <= 0) clearInterval(repeatFunc)
				}, 16)

				//Begin palette commands
				if (onCooldown || canvasLocked) return
				//"Enter" key to place selected block without using mouse
				if (e.keyCode == 13 && !("value" in document.activeElement)) call(onOkClicked, pok, e)
				//Keyboard shortcuts for selecting palette colours
				let keyIndex = null
				if (document.activeElement != document.body)return
				keyIndex = (localStorage.paletteKeys || DEFAULT_PALETTE_KEYS).indexOf(e.key)
				if (keyIndex == -1) return
				if (palette.style.transform == "translateY(100%)")
					showPalette()
				for (let c = 0; c < document.getElementById("colours").children.length; c++) {
					document.getElementById("colours").children[c].firstChild.style.visibility = "visible"
				}
				let colourI = [...(document.getElementById("colours").children)]
					.indexOf(document.getElementById("colours").children[keyIndex])
				if (colourI < 0) return
				let el = document.getElementById("colours").children[PEN]
				if (el) {
					el.classList.remove("sel")
				}
				PEN = keyIndex;
				AUDIOS.selectColour.run()
				canvselect.style.background = document.getElementById("colours").children[keyIndex].style.background
				document.getElementById("colours").children[keyIndex].classList.add("sel")
				pok.classList.add("enabled")
				canvselect.children[0].style.display = "none"
				canvselect.style.outline= "8px white solid"
				canvselect.style.boxShadow= "0px 2px 4px 0px rgb(0 0 0 / 50%)"
			})

			call(addEventListener, document.body, "touchend", function(e) {
				if (!e.isTrusted) return

				for (let t of e.changedTouches) {
					assign2: if (touch2 && touch2.identifier == t.identifier) touch2 = null
					else if (touch1 && touch1.identifier == t.identifier) {
						[touch1, touch2] = [touch2, null]
						if (touchmoved > 0 && canvparent2.contains(e.target)){
							if (e.target != maincontent && !canvparent2.contains(e.target))
								break assign2
							clicked(t.clientX, t.clientY)
						}
					}
					if ("value" in e.target) e.target.focus()
					let target = e.target
					while (!target.dispatchEvent) {
						target = target.parentElement
					}
					if (target == pok) {
						call(onOkClicked, pok, e)
					}
					else {
						if (touchmoved > 0)
							target.dispatchEvent(new MouseEvent('click', { bubbles:true } ))
					}
				}
			})

			call(addEventListener, signupButton, 'click', function(e) {
				signupUsername.style.border = 'initial'
				signupEmail.style.border = 'initial'
				if (signupUsername.value.length < 4) {
					signupUsername.style.border = '1px solid red'
					loginSignupMessage.textContent = 'Username is too short!'
					return
				}
				if (!signupEmail.validity.valid) {
					signupEmail.style.border = '1px solid red'
					loginSignupMessage.textContent = 'Email is not valid!'
					return
				}
				loginSignupMessage.textContent = ''
				/*authCodePage.style.display = 'flex'
				signupPage.style.display = 'none'*/

				let buffer = encoder.encode('X' + signupUsername.value.padEnd(32) + signupEmail.value.padEnd(320))
				buffer[0] = 2 // ClientPackets.CreateAccount
				call(send, authSocket, buffer)
			})
			call(addEventListener, signinButton, 'click', function() {
				let buffer = encoder.encode('X' + loginUsername.value.padEnd(32) + loginEmail.value.padEnd(320))
				buffer[0] = 5 //ClientPackets.Authenticate
				call(send, authSocket, buffer)
				/*authCodePage.style.display = 'flex'
				signinPage.style.display = 'none'*/
			})
			call(addEventListener, authCodeButton, 'click', function() {
				let buffer = encoder.encode('X' + authCode.value)
				buffer[0] = 3 // ClientPackets.AccountCode
				call(send, authSocket, buffer)
				/*authCodePage.style.display = 'none'
				signinPage.style.display = 'flex'*/
			})
			call(addEventListener, profileDiscordSubmit, 'click', function() {
				let view = new DataView(new Uint8Array(10).buffer)
				view.setUint8(0, 11) // ClientPackets.UpdateProfile
				view.setUint8(1, 1) // PublicEditableData.DiscordSnowflake
				view.setBigInt64(2, BigInt(parseInt(profileDiscordInput.value)))
				call(send, authSocket, view.buffer)
				call(send, authSocket, new Uint8Array([4]))
			})
			call(addEventListener, profileTwitterSubmit, 'click', function() {
				let buffer = encoder.encode('XX' + profileTwitterInput.value)
				buffer[0] = 11 // ClientPackets.UpdateProfile
				buffer[1] = 2 // PublicEditableData.TwitterHandle
				call(send, authSocket, buffer)
				call(send, authSocket, new Uint8Array([4]))
			})
			call(addEventListener, profileRedditSubmit, 'click', function() {
				let buffer = encoder.encode('XX' + profileRedditInput.value)
				buffer[0] = 11 // ClientPackets.UpdateProfile
				buffer[1] = 3 // PublicEditableData.RedditHandle
				call(send, authSocket, buffer)
				call(send, authSocket, new Uint8Array([4]))
			})

			function _requestLoadChannelPrevious(msgCount=64) {
				chatPreviousLoadDebounce = true
				const encChannel = encoder.encode(currentChannel)
				let view = new DataView(new Uint8Array(6 + encChannel.byteLength).buffer)
				view.setUint8(0, 13)
				view.setUint32(1, chatMessages.children[0]?.messageId || 0)
				view.setUint8(5, msgCount|128) // 128 = before (most significant bit)
				for (let i = 0; i < encChannel.byteLength; i++) {
					view.setUint8(6 + i, encChannel[i])
				}
				call(send, ws, view.buffer)
			}
			requestLoadChannelPrevious = _requestLoadChannelPrevious
			call(addEventListener, chatMessages, "scroll", () => {
				if (chatMessages.scrollTop < 4) {
					if (chatPreviousAutoLoad === true && chatPreviousLoadDebounce === false) {
						_requestLoadChannelPrevious()
					}
					else {
						chatPreviousButton.dataset.hidden = "false"
					}
				}
				else {
					chatPreviousButton.dataset.hidden = "true"
				}
			})
			call(addEventListener, chatPreviousButton, "click", () => {
				_requestLoadChannelPrevious()
				// Keep loading previous for this channel as they scroll up
				chatPreviousAutoLoad = true
			})
			call(addEventListener, modOptionsButton, "click", function() {
				const reason = modReason.value.slice(0, 300)
				const encReason = encoder.encode(reason)
				// 0 - kick, 1 - mute, 2 - ban, 3 - captcha, 4 - delete
				let action = null
				let view = null
				let offset = 2
				let statusMsg = ""

				function setModView(extraLength) {
					view = new DataView(new Uint8Array(2 + extraLength + encReason.byteLength).buffer)
					view.setUint8(0, 98)
				}
				function setModReason(offset) {
					for (let ri = 0; ri < encReason.byteLength; ri++) {
						view.setUint8(offset + ri, encReason[ri])
					}
				}
				if (modActionKick.checked) {
					setModView(4)
					view.setUint8(1, 0)
					view.setUint32(2, modMemberId.value)
					setModReason(6)
					statusMsg = `Kicked player ${modMemberId.value} with reason '${reason}'`
				}
				else if (modActionMute.checked || modActionBan.checked) {
					const action = modActionMute.checked ? 1 : 2
					const seconds = (+modDurationS.value||0)
					const minutes = (+modDurationM.value||0)
					const hours = (+modDurationH.value||0)
					setModView(8)
					view.setUint8(1, action)
					view.setUint32(2, modMemberId.value)
					view.setUint32(6, seconds + minutes * 60 + hours * 3600)
					setModReason(10)
					statusMsg = `${["Kicked","Banned"][action-1]} player ${modMemberId.value} for ${hours
						} hours, ${minutes} minutes, and ${seconds} seconds with reason '${reason}'`
				}
				else if (modActionCaptcha.checked) {
					setModView(4)
					view.setUint8(1, 3)
					view.setUint32(2, modAffectsAll.checked ? 0 : modMemberId.value)
					setModReason(6)
					statusMsg = `Forced captcha for ${modAffectsAll.checked ? "all users" : "user " + modMemberId.value
						} with reason '${reason}'`
				}
				else if (modActionDelete.checked) {
					setModView(4)
					view.setUint8(1, 4)
					view.setUint32(2, modMessageId.value)
					setModReason(6)
					statusMsg = `Deleted message ${modMessageId.value} with reason '${reason}'`
				}
				else return
				call(send, ws, view.buffer)
				alert(statusMsg)
			})
		}).bind(undefined, WebSocket.prototype.send, addEventListener, btoa.call.bind(btoa.call));
		WebSocket.prototype.send = function(){this.close()}; document.execCommand = (_) => {window.location.reload(true)};
	</script>
	<script src="https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit"></script>
	<script type="application/javascript" src="virtual-select.min.js"></script>
	<script type="application/javascript" src="uv.min.js"></script>
	<script type="application/javascript" src="elements.js?v=6" defer></script>
	<script type="application/javascript" src="event-timer.js" defer></script>
	<script type="application/javascript" src="quests.js" defer></script>
	<script type="application/javascript" src="captcha-canvas.js"></script>
	<script type="application/javascript" src="darkplace.js"></script>
	<script type="application/javascript" src="canvas-snow.min.js"></script>
	<script type="application/javascript" src="snowplace.js"></script>
	<script type="application/javascript" src="shared.js?v=2"></script>
	<script type="application/javascript" src="tsparticles.confetti.bundle.min.js"></script>
	<link rel="stylesheet" type="text/css" href="virtual-select.min.css">
	<link rel="manifest" href="manifest.json">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<link rel="apple-touch-icon" href="favicon.png">
	<meta name="apple-mobile-web-app-title" content="place">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link href="style.css?v=347" rel="stylesheet"> <!-- Increment the CSS query, such as ?v=1.x every time CSS is changed in order to force clients to refresh their stylesheets. Otherwise broken CSS may occur-->
	<title>place</title>
	<link rel="icon" type="image/x-icon" href="favicon.png">
<meta property="og:title" content="r/place 2"/>
<meta property="og:description" content="There is an empty canvas. You may place a tile upon it, but you must wait to place another. Individually you can create something. Together you can create something more." />
<meta property="og:image" content="https://preview.redd.it/rreqw9qpy8r81.png?auto=webp&s=f58d371c5505d66439c82de9040dfd99a3685015" />
<meta name="theme-color" content="#ff4500">
</head>
	<body>
		<div id="loadingScreen">
			<img src="images/rplace-loader.gif" style="position: absolute; width: 128px; height: 128px; z-index: 22;"/>
			<canvas id="waitingGameCanvas" style="width: 100%; height: 100%; z-index: 21;"></canvas>
			<div id="connproblems">
				<span translate="connectionProblems">Connection problems?</span>
				<a onclick="localStorage.clear(); history.pushState(null, '', location.origin)" href translate="tryClickingHere">try clicking here</a>
				<br>
				or tweet us
				<a href="https://twitter.com/rplacetk">@rplacetk</a>
			</div>
		</div>
		<div id="maincontent">
			<div id="bgWrapper" style="z-index: -1; position: absolute; pointer-events: none; left: 0; top: 0; width: 100%; height: 100%;">
				<!--Special background effects or features can be rendered within here-->
			</div>
			<div id="posel" noselect>(0,0) 2.5x</div>
			<div id="overlayMenu" noselect class="toast-menu">
				<div style="display: flex;">
					<h2 title="Make use of a canvas overlay image in order to help yourself better position your pixels" style="display: inline;flex-grow: 1;">Overlay:</h2>
					<r-close-icon onclick="overlayMenu.removeAttribute('opened')" class="active"></r-close-icon>
				</div>
				<br><br>
				<input id="overlayInput" type="file" style="width: 100%;"/> <br><br>
				<input value="" type="number" onchange="
					overlayInfo.x = +this.value || 0
					templateImage.style.transform = `translate(${overlayInfo.x}px, ${overlayInfo.y}px)`
				" placeholder="Image X" style="width: calc(50% - 5px); margin-right: 5px;"/>
				<input value="" type="number" onchange="
					overlayInfo.y = +this.value || 0
					templateImage.style.transform = `translate(${overlayInfo.x}px, ${overlayInfo.y}px)`
				" placeholder="Image Y" style="width: calc(50% - 5px)"/> <br><br>
				<div style="width: 100%; position: relative;">
					<input id="overlayOpacity" type="range" onchange="
						overlayInfo.opacity = (+this.value || 80) / 100
						templateImage.style.opacity = overlayInfo.opacity
					" min="0" value="80" max="100" style="width: 100%;" oninput="overlaySliderValue.textContent = Math.min(this.value, 99); overlaySliderValue.style.left = `calc(${this.value / 100} * 90%)`;"/>
					<label for="overlayOpacity" style="position: absolute;left: 8px;top: 50%;transform: translateY(-50%);opacity: 0.6;">Opacity</label>
					<span id="overlaySliderValue" style="position: absolute; white-space: pre-wrap; left: calc(0.8 * 90%); transform: translateX(10px); bottom: 12.5px; pointer-events: none; width: 16px; text-align: center;">80</span>
				</div>
				<br>
				<div style="position: relative; display: flex;" onclick="
					event.stopPropagation();
					(async function(_this){
						let uriString = await generateOverlayUrl()
						if (uriString.length < 2000) {
							navigator.clipboard.writeText(uriString)
							_this.children[2].animate([
								{ opacity: 1 },
								{ scale: 1.1 }
							], { duration: 1000, iterations: 1 })
						}
						else {
							_this.children[2].textContent = 'Failed: Overlay is too big!'
							_this.children[2].animate([
								{ opacity: 1 },
								{ color: 'red' }
							], { duration: 1000, iterations: 1 })
							if (_this['failMsgTimeout']) clearTimeout(_this['failMsgTimeout'])
							_this['failMsgTimeout'] = setTimeout(() => {
								_this.children[2].textContent = 'Copied to clipboard!'
							}, 1000)
						}
					})(this);
				" title="copy canvas link">
					<img class="icon-image" src="svg/clipboard.svg">
					<span style="align-self: center; margin-right: 8px;cursor: pointer;">Copy overlay URL</span>
					<span style="opacity: 0; align-self: center;">Copied to clipboard!</span>
				</div>
			</div>
			<div noselect="" class="toast-menu" id="turnstileMenu">
				<div style="display: flex;">
					<h2 title="Make use of a canvas overlay image in order to help yourself better position your pixels"
						style="display: inline;flex-grow: 1;">Verifying session...</h2>
						<r-close-icon style="opacity: 0.6; pointer-events: none;" class="active"></r-close-icon>
				</div>
				<p>Don't worry, this process should be automatic!</p><br>
				<div id="turnstileContainer"></div>
			</div>
			<div id="moderationMenu" noselect="" mode="delete" class="toast-menu">
				<div style="display: flex;margin-bottom: 16px;">
					<h2 style="display: inline;flex-grow: 1;">Moderation options:</h2>
					<r-close-icon onclick="closeChatModerate()"></r-close-icon>
				</div>
				<h4>Manage:</h4>
				<div id="modMessageIdForm" class="mod-form">
					<input type="number" id="modMessageId" title="Message ID" placeholder="Message ID" oninput="
						let found = null
						for (let message of cMessages[currentChannel]) { if (message.messageId == this.value) {
							found = message
						}}
						modMessagePreview.innerHTML = found?.innerHTML ?? 'Message not found'">
					<div id="modMessagePreview">Message not found</div>
				</div>
				<input type="number" id="modMemberId"  title="Member ID" placeholder="Member ID">
				<h4>Action:</h4>
				<div id="modActionForm" class="mod-form">
					<div onclick="moderationMenu.setAttribute('mode', 'delete')">
						<input type="radio" id="modActionDelete" name="modaction" />
						<label for="modActionDelete">Delete message</label>
					</div>
					<div onclick="moderationMenu.setAttribute('mode', 'kick')">
						<input type="radio" id="modActionKick" name="modaction" />
						<label for="modActionKick">Kick</label>
					</div>
					<div onclick="moderationMenu.setAttribute('mode', 'mute')">
						<input type="radio" id="modActionMute" name="modaction" />
						<label for="modActionMute">Mute</label>
					</div>
					<div onclick="moderationMenu.setAttribute('mode', 'ban')">
						<input type="radio" id="modActionBan" name="modaction" />
						<label for="modActionBan">Ban</label>
					</div>
					<div onclick="moderationMenu.setAttribute('mode', 'captcha')">
						<input type="radio" id="modActionCaptcha" name="modaction" />
						<label for="modActionCaptcha">Captcha</label>
					</div>
				</div>
				<div id="modDuration">
					<input id="modDurationH" type="number" style="display: inline;height: auto;width: 80px;" placeholder="Hours" min="0">
					<span>:</span>
					<input id="modDurationM" type="number" style="display: inline;height: auto;width: 80px;" placeholder="Minutes" min="0">
					<span>:</span>
					<input id="modDurationS" type="number" style="display: inline;height: auto;width: 80px;" placeholder="Seconds" min="1">
				</div>
				<div id="modAffectsAllForm" class="mod-form">
					<div>
						<input type="checkbox" id="modAffectsAll" style="height: auto; width: 12px;" value="affectsall" />
						<label for="modAffectsAll">Apply to all players</label>
					</div>
				</div>
				<em>All moderation actions are logged by the server and reports sent to all other staff. Follow the moderation rules. Do not abuse power.</em>
				<input id="modReason" type="text" placeholder="Reason" oninput="modOptionsButton.disabled = !this.value">
				<div style="display: flex; column-gap: 8px;">
					<button style="flex-grow: 1;" id="modOptionsButton" disabled="true">Submit</button>
					<button style="flex-grow: 1;" onclick="closeChatModerate()">Cancel</button>
				</div>
			</div>
			<div noselect id="place" tabindex="0" onclick="
				if (initialConnect && CD < Date.now()) {
					zoomIn()
					showPalette()

					// Persistent colours on mobile platforms
					if (PEN != -1) {
						pok.classList.add('enabled')
						canvselect.style.background = colours.children[PEN].style.background
						canvselect.children[0].style.display = 'none'
						canvselect.style.outline = '8px white solid'
						canvselect.style.boxShadow = '0px 2px 4px 0px rgb(0 0 0 / 50%)'
					}
				}
				else {
					AUDIOS.invalid.run()
				}
			" translate="connecting">Connecting...</div>
			<canvas id="canvas" width="0" height="0" noselect></canvas>
			<div id="canvparent1" noselect>
				<img id="edge" height="226" width="290" src="images/snoo-edge.png" />
			</div>
			<div id="canvparent2" noselect>
				<div id="canvselect">
					<img theme="pixelselect" src="svg/pixel-select-2022.svg" style="position: absolute; top: -10%; left: -10%; width: 120%; height: 120%" ondragstart="return false">
				</div>
				<img id="templateImage" width="auto" height="auto" ondrag="return">
				<placechat id="idPosition" style="display: none;">
					<span translate="placedBy">Placed by:</span>
					<span><!--placer name||id--></span>
				</placechat>
			</div>
			<div noselect id="captchaPopup" style="display: none;">
				<canvas id="captchaCanvas" width="500" height="800"></canvas>
				<h1 noselect style="color: grey;">ü§î Sorry for interrupting, but</h1>
				<p noselect translate="captchaPrompt"><em>Solve this small captcha to help keep rplace.live fun for all...</em></p>
				<hr>
				<h2 id="captchaLabel">Please click the button containing the emoji you see below</h2>
				<div id="captchaImagePositon"><!--captcha canvas image space--></div>
				<a style="text-align: center;" href=".">(generate new captcha)</a>
				<div id="captchaOptions"><!--clickable captcha answers--></div>
			</div>
			<div id="chatbtn" tabindex="0" class="layout" noselect onclick="openChatPanel()">
				<img class="icon-image" src="svg/chat.svg" style="width:16px; height:21px">
			</div>
			<dialog id="popup">
				<div>
					<r-close-icon onclick="timelapseEmbed?.remove(); localStorage.nopopup = Date.now(); popup.close()"></r-close-icon>
					<span noselect style="font-size: 1.2em; margin-bottom: 16px;" translate="specialEventTitle">Special event - 2023-2024 full canvas timelapse released!</span>
					<!--<img src="images/discord-popup.png" style="width: 100%;position: absolute;bottom: 0;cursor: pointer;"
							onclick="window.open('https:\/\/www.reddit.com/r/place/?screenmode=fullscreen&amp;cx=585&amp;cy=362&amp;px=20')">
					<iframe id="timelapseEmbed" src="https://www.youtube-nocookie.com/embed/H67q2HfYl7s" title="YouTube video player"
						frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
						allowfullscreen="true" width="100%" height="100%"></iframe>-->
				</div>
			</dialog>
			<div noselect id="helpbtn" tabindex="0" class="layout" onclick="
				if (modal.style.display == 'flex') {
					modal.style.display = 'none'
					bg.style.display = 'none'
				}
				else {
					modal.style.display = 'flex'
					bg.style.display = 'block'
				}
			">
				<img class="icon-image" src="svg/help.svg">
			</div>
			<div noselect id="closebtn" tabindex="0" class="layout" onclick="
				bg.style.opacity = '0.5'
				bg.style.display = 'block'
				closeChatPanel()

				document.body.id = 'out'
				window.onresize()
			">...</div>
			<div id="bg" style="display:none;position:absolute;top:0;left:0;bottom:0;right:0;background:rgba(0,0,0,.4);z-index:6"></div>
			<div id="modal" style="display:none">
				<div class="modal-header">
					<h2>Place</h2>
					<r-close-icon onclick="
						modal.style.display='none'
						bg.style.display='none'"></r-close-icon>
				</div>
				<div class="modal-content" translate="modalAboutContent">
					There is an empty canvas.<br><br>
					You may place a tile upon it, but you must wait to place another.<br><br>
					Individually you can create something.<br><br>
					Together you can create something more.<br><br>
				</div>
				<div class="modal-install" noselect onclick="pwaPrompter?.prompt()">Install rplace.live web app</div>
				<p class="modal-content" style="text-align: center;opacity: 0.6;margin-top: 16px;margin-bottom: 0px;font-size: 14px;">
					¬© Zekiah-A, BlobKat
				</p>
				<div class="modal-footer">
					<img noselect="" alt="Place Logo" height="40" width="40" src="images/rplace.png" style="position: absolute;left: 50%;transform: translateX(-50%);opacity: 0.2;">
					<mute-button noselect class="modal-footer-button" title="Enable sounds" onclick="
						muted = !muted
						localStorage.muted = +muted
						mutesvg.innerHTML = muted ? MUTED_SVG : UNMUTED_SVG
					">
						<svg xmlns="http://www.w3.org/2000/svg" id="mutesvg" class="icon-image" viewBox="0 0 20 20"></svg>
					</mute-button>
					<div id="themeDropParent" noselect class="modal-footer-button" style="width: auto; align-items: center;justify-content: center;"
						onclick="event.stopPropagation(); themeDropParent.toggleAttribute('open')">
						<span style="white-space: nowrap;" id="themeDropName">üñåÔ∏è r/place 2022</span>
						<svg class="icon-image" style="vertical-align: bottom;" xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24">
							<path d="M480-345 240-585l43-43 197 198 197-197 43 43-240 239Z"></path>
						</svg>
						<div id="themeDrop" style="top: 40px;" class="context-menu" ontouchstart="event.stopPropagation()">
							<ul onclick="
								{
									let target = event.target
									while (target && target != this) {
										if (target.nodeName != 'LI') {
											target = target.parentElement
											continue
										}
										let targetEffects = target.getAttribute('effects')
										let targetVariant = target.getAttribute('variant')
										let targetTheme = target.getAttribute('theme')
										themeDropParent.removeAttribute('open')
										event.stopPropagation()

										if (targetTheme) {
											themeDropName.textContent = 'üñåÔ∏è ' + targetTheme
											theme(DEFAULT_THEMES.get(targetTheme), targetVariant, targetEffects)
											localStorage.theme = targetTheme
											localStorage.variant = targetVariant
											localStorage.effects = targetEffects
										}
										break
									}
								}
							">
								<li theme="r/place 2022" variant=""><span>r/place 2022 (Classic)</span></li>
								<li theme="r/place 2022" variant="dark"><span>r/place 2022 (Dark)</span></li>
								<li theme="r/place 2023" variant=""><span>r/place 2023 (Classic)</span></li>
								<hr style="opacity: 0.2">
								<li theme="r/place 2022" variant="dark" effects="darkplace"><span>darkplace.live (April fools)</span></li>
								<li theme="r/place 2022" variant="" effects="winter"><span>snowplace.live (December 2023)</span></li>
							</ul>
						</div>
					</div>
					<place-chat-button id="placeChatButton" class="modal-footer-button" title="Enable canvas chat" onclick="
						placeChat = !placeChat
						localStorage.placeChat = String(placeChat)
						this.children[0].style.opacity = placeChat ? '1' : '0.6'
					">
						<img src="svg/place-chat.svg" width="60">
					</place-chat-button>
				</div>
			</div>
			<div id="palette" style="transform: translateY(100%)" noselect>
				<div style="position: relative;">
					<div id="canvasLock" style="display: none;">
						<img src="svg/lock.svg" style="width: 36px;"> <span translate="lockMessage">This canvas is locked... You can't place pixels here anymore</span>
					</div>
					<div id="colours"></div>
				</div>
				<div class="buttons">
					<div class="pcancel" onclick="
						AUDIOS.closePalette.run()
						canvselect.style.background = ''
						palette.style.transform = 'translateY(100%)'
						if (PEN != -1) {
							colours.children[PEN].classList.remove('sel')
							PEN = -1
						}
						pok.classList.remove('enabled')
						canvselect.children[0].style.display = 'block'
						canvselect.style.outline = ''
						canvselect.style.boxShadow = ''
						hideIndicators()
					">
						<svg class="icon-image" xmlns="http://www.w3.org/2000/svg" data-name="icons final" viewBox="0 0 20 20">
							<path d="M18.442 2.442l-.884-.884L10 9.116 2.442 1.558l-.884.884L9.116 10l-7.558 7.558.884.884L10 10.884l7.558 7.558.884-.884L10.884 10l7.558-7.558z"></path>
						</svg>
					</div>
					<div id="pok" class="pok">
						<svg class="icon-image" xmlns="http://www.w3.org/2000/svg" data-name="icons final" viewBox="0 0 20 20">
							<path d="M7.5 15.583a.72.72 0 01-.513-.212L1.558 9.942l.884-.884L7.5 14.116 18.058 3.558l.884.884L8.013 15.371a.72.72 0 01-.513.212z"></path>
						</svg>
					</div>
				</div>
			</div>
		</div>
		<div id="more" ontouchstart="event.stopPropagation()" ontouchend="event.stopPropagation()">
			<div id="spaceFiller" onclick="
				if (document.body.id != 'out')
					return
				bg.style.opacity = '1'
				bg.style.display = 'none'
				document.body.id = ''
				window.onresize()
			"></div>
			<iframe id="postsFrame" src="posts.html" title="posts" onload="resizePostsFrame()" frameborder="0" scrolling="no"></iframe>
		</div>
		<div id="chatPanel" ontouchstart="messageInput.blur(); chatContext.style.display = 'none'; channelDropParent.removeAttribute('open')"
				onclick="chatContext.style.display = 'none'; channelDropParent.removeAttribute('open')">
			<div id="namePanel">
				<h2 id="namePanelHeader" translate="nicknameToContinue">Enter a nickname to continue:</h2>
				<h4 id="nicknameSubheading" style="color: lightgrey;" translate="pleaseBeRespectful">Please be respectful and try not to spam!</h4>
				<br>
				<div class="name-input-container">
					<input id="nameInput" type="text" placeholder="Enter nickname..." translate="enterNickname"
						onkeydown="if (event.keyCode == 13) setName(this.value)"
						oninput="this.value = this.value.replace(/\W+/g, '').toLowerCase()" maxlength="16">
					<button onclick="setName(nameInput.value)">
						<img src="svg/green-checkmark.svg">
					</button>
				</div>
			</div>
			<div class="chat-header" noselect>
				<p style="white-space:nowrap" translate="liveChat" style="display: none;" style="display: none;" class="live-chat-header2">Live Chat:</p>
				<h2 style="white-space:nowrap" translate="liveChat" class="live-chat-header1">Live Chat:</h2>
				<div class="channels-options">
					<span id="channelDropParent" style="opacity: 1;">
						<svg class="icon-image" onclick="event.stopPropagation(); channelDropParent.toggleAttribute('open')" title="Change channel" style="vertical-align: bottom;" xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24">
							<path d="M480-345 240-585l43-43 197 198 197-197 43 43-240 239Z"/>
						</svg>
						<div id="channelDrop" class="context-menu" ontouchstart="event.stopPropagation()">
							<ul onclick="
								let target = event.target
								while (target && target != this) {
									if (target.nodeName != 'LI') {
										target = target.parentElement
										continue
									}
									let lang = target['lang']
									if (lang != extraLanguage && lang != 'en') extraChannel(lang)
									switchLanguageChannel(lang)
									event.stopPropagation()
									channelDropParent.removeAttribute('open')
									break
								}
							"><!--Language channel options--></ul>
						</div>
					</span>
					<span id="channelMine" style="opacity: 0.5;" onclick="switchLanguageChannel(extraLanguage)">
						<img id="channelMineImg" style="height: 20px; vertical-align:sub"><span id="channelMineName"></span>
					</span>
					<span id="channelEn" style="opacity: 0.5;" onclick="switchLanguageChannel('en')">
						<img src="svg/flag-gb.svg" style="height: 20px; vertical-align:sub">EN
					</span>
				</div>
				<div id="onlinepanel" noselect>
					<p id="onlineCounter">...</p>
					<svg id="playerIcon" stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg" style="display: inline;">
						<path d="M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"></path>
					</svg>
				</div>
				<r-close-icon onclick="closeChatPanel()" class="active"></r-close-icon>
			</div>
			<div id="chatContext" class="context-menu" style="display:none">
				<ul>
					<li style="font-size: 8px; display: none;" id="userNote"></li>
					<li id="mentionUser">
						<a translate="mention" onclick="
							chatMentionUser(targetedIntId)
							chatContext.style.display = 'none'
						">Mention user</a>
					</li>
					<li id="replyUser">
						<a translate="replyTo" onclick="
							chatReply(targetedMsgId, targetedIntId)
							chatContext.style.display = 'none'
						">Reply to user</a>
					</li>
					<li id="blockUser">
						<a translate="block" onclick="
							if (blockedUsers.includes(targetedIntId))
								blockedUsers.splice(blockedUsers.indexOf(targetedIntId), 1)
							else if (targetedIntId != intId)
								blockedUsers.push(targetedIntId)
							localStorage.blocked = blockedUsers
							chatContext.style.display = 'none'
						">Block user</a>
					</li>
					<li id="changeMyName" style="display: none;">
						<a onclick="
							namePanel.style.visibility = 'visible'
							nameInput.value = intIdNames.get(intId)
							chatContext.style.display = 'none'
						"><em translate="changeMyName">Change my name</em></a>
					</li>
				</ul>
			</div>
			<a id="ad" target="_blank">
				<button class="ad-close" onclick="
					event.preventDefault()
					ad.style.display = 'none'
					localStorage.noad = Date.now()
					adLabel.style.display = 'block'
					adLabel.animate([
						{ opacity: 1 },
						{ scale: 1.1 }
					], { duration: 1000, iterations: 1, })
					setTimeout(() => adLabel.style.display = 'none', 1000)
				">x</button>
			</a>
			<span id="adLabel" style="display: none; opacity: 0; align-self: center;" translate="adHidden">Ad hidden for 14 days!</span>
			<div id="chatPreviousButton" class="horizontal-labeled-separator" noselect><hr><span>See previous messages</span><hr></div>
			<div id="chatMessages"><!--Live chat messages--></div>
			<div id="messageTypePanel" class="chat-input-panel" closed>
				<input type="button" class="messageTypeBtn" title="Use the shortcut 'ctrl+enter' to send quickly" style="left: 5px;" translate="putOnCanvas" value="ü´ß Put on canvas">
				<input type="button" class="messageTypeBtn" title="Use the shortcut 'enter' to send quickly" style="right: 5px;" translate="sendInLiveChat" value="üì® Send in live chat">
			</div>
			<div id="messageEmojisPanel" class="chat-input-panel" closed><!--Message emoji suggestions--></div>
			<div id="messageReplyPanel" class="chat-input-panel" closed>
				<div id="messageReplyLabel">Replying to:</div>
				<div style="cursor: pointer;" onclick="chatCancelReplies()">
					<svg class="icon-image" xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" height="24" width="32">
						<path d="m330-288 150-150 150 150 42-42-150-150 150-150-42-42-150 150-150-150-42 42 150 150-150 150 42 42ZM480-80q-82 0-155-31.5t-127.5-86Q143-252 111.5-325T80-480q0-83 31.5-156t86-127Q252-817 325-848.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 82-31.5 155T763-197.5q-54 54.5-127 86T480-80Zm0-60q142 0 241-99.5T820-480q0-142-99-241t-241-99q-141 0-240.5 99T140-480q0 141 99.5 240.5T480-140Zm0-340Z"></path>
					</svg>
				</div>
			</div>
			<div class="chat-input-panel" id="chatPunishPanel" closed>
				<h3>Punishment notice:</h3>
				<span id="chatPunishNote"></span>
				<input type="button" value="See detailed info" style="width: fit-content;" onclick="
					chatPunishInfo.style.display = chatPunishInfo.style.display == 'block' ? 'none' : 'block'
				">
				<pre id="chatPunishInfo" style="display: none;"></pre>
			</div>
			<div style="display: flex; column-gap: 8px; z-index: 1;">
				<textarea id="messageInput" onclick="openChatPanel()" type="text" placeholder="Enter message..." translate="enterMessage" enterkeyhint="send" maxlength="200"></textarea>
				<button class="message-options" onclick="messageTypePanel.toggleAttribute('closed')">...</button>
			</div>
		</div>
		<div id="timelapsePanel" noselect style="display: none;">
			<h2>Timelapse Tool</h2>
			<r-close-icon onclick="timelapsePanel.style.display = 'none'" class="active" style="position: absolute; top: 10px; right: 10px;"></r-close-icon>
			<div style="width: 100%; height: 40%; transform: translateX(-10px); margin: 10px; border: 1px solid gray; border-radius: 2px; overflow: scroll;">
				<img id="tlImage" style="position: relative;">
					<div id="tlSelect" style="position: absolute; left: 0; top: 0; background-color: rgba(0, 200, 250, 0.7); resize: both; overflow: auto;" onmousedown="this.setAttribute('dragging',  true);" onmouseup="this.setAttribute('dragging', false);" onmousemove="tlMouseMove(event)" ondragstart="return false"></div>
				</img>
			</div>
			<div id="tlStartSel" class="virtselect"></div>
			<div id="tlEndSel" class="virtselect"></div>
			<!--<select id="tlStartSel" style="width: 100%; margin-bottom: 5px; border-radius: 4px;"> <option value="">Select timelapse start backup</option> </select> <select id="tlEndSel" style="width: 100%; margin-bottom: 5px; border-radius: 4px;"> <option value="">Select timelapse end backup</option> </select>-->
			<input id="tlFps" type="number" style="width: 100%; margin-bottom: 10px; border-radius: 0px; box-shadow: none; font-size: 14px; font-family: sans-serif; color: rgba(0,0,0,0.8); border: 1px solid #ddd;" min="1" max="30" placeholder="Desired timelapse framerate" />
			<div id="tlPlayDir" style="text-align: center;" reverse="true">
				<span style="font-size: 18px; cursor: pointer; opacity: 0.5;" onclick="this.parentElement.setAttribute('reverse', false); this.style.opacity='1'; this.nextElementSibling.style.opacity='0.5';">Play normally</span> / <span style="font-size: 18px; cursor: pointer;" onclick="this.parentElement.setAttribute('reverse', true); this.style.opacity='1'; this.previousElementSibling.style.opacity='0.5';">Play in reverse</span>
			</div>
			<input id="tlConfirm" type="button" style="position: absolute; left: 50%; bottom: 0px; transform: translateX(-50%) translateY(-50%); width: 80%; height: 60px; border-radius: 4px; border: 1px solid #C3C3C3; box-shadow: none; cursor: pointer;" onclick="confirmTlCreate()" value="Create"/>
			<span id="tlTimer" style="position: absolute; left: 50%; bottom: 0px; transform: translateX(-50%) translateY(-50%);">0.0s</span>
		</div>

		<!--My account panel-->
		<dialog id="loginPopup" class="reddit-modal">
			<div id="loginPanel" data-page="unauthed">
				<div class="header">
					<h4 style="margin: 0px;">My account</h4>
				</div>
				<r-close-icon onclick="loginPopup.close()" class="active" style="position: absolute; top: 10px; right: 10px;"></r-close-icon>
				<div id="unauthedPage" class="body" page="unauthed" data-page="signin">
					<div id="signinPage" class="body" page="signin">
						<h4>Sign in</h4>
						<input type="text" class="reddit-modal-input" placeholder="Username*" id="loginUsername" maxlength="32" minlength="4">
						<input type="email" class="reddit-modal-input" placeholder="Email*" id="loginEmail">
						<button type="button" class="reddit-modal-button" id="signinButton" onclick="
							unauthedPage.dataset.page = 'authcode'
						">Continue</button>
					</div>
					<div id="signupPage" class="body" page="signup">
						<h4>Sign up</h4>
						<input type="text" class="reddit-modal-input" placeholder="Username*" id="signupUsername" maxlength="32" minlength="4">
						<input type="email" class="reddit-modal-input" placeholder="Email*" id="signupEmail" required>
						<button type="button" class="reddit-modal-button" id="signupButton">Continue</button>
						<span id="loginSignupMessage"></span>
					</div>
					<div id="authCodePage" class="body" page="authcode">
						<div style="display: flex;align-items: center; column-gap: 8px; margin-bottom: 10px;">
							<button type="button" onclick="unauthedPage.dataset.page='signin'" style="display: inline; background: transparent; padding: 0px; box-shadow: none;">
								<image src="svg/icon-back.svg"></image>
							</button>
							<h3 style="display: inline-block;">Email verification</h3>
						</div>
						<h4>If you're lucky, an email has been sent to your inbox</h4>
						<p>Enter the code sent below to authenticate your account</p>
						<input type="text" class="reddit-modal-input" placeholder="Authentication code*" id="authCode" autocomplete="off" minlength="10">
						<button type="button" class="reddit-modal-button" id="authCodeButton">Submit</button>
					</div>
					<div style="flex-grow: 1"></div>
					<h4>Other options:</h4>
					<div style="display: flex;column-gap: 8px;margin: 8px;">
						<button type="button" class="reddit-signin-button" noselect onclick="
							let csrf = (Math.random() + 1).toString(36).substring(2)
							window.open('https:\/\/www.reddit.com/api/v1/authorize?client_id=eqjRPVmD2M7InsCDhBdvVg&response_type=code'
								+ '&state='+csrf+'&redirect_uri=https:\/\/rplace.live/&duration=permanent&scope=identity')
							window.close()
						">
							<img src="images/reddit.png" style="height: 100%;"><span style="align-self: center;">Sign in with reddit</span>
						</button>
						<a href="#" ontouchend="event.preventDefault(); this.click()" onclick="{
							event.preventDefault()
							let isSigninPage = unauthedPage.dataset.page === 'signin'
							unauthedPage.dataset.page = isSigninPage ? 'signup' : 'signin'
							//this.textContent = translate(isSigninPage ? 'signInInstead' : 'createNewAccount')
						}" style="align-self: center;" translate="createNewAccount">Create a new account</a>
					</div>    
				</div>
				<div class="body" style="display: none;overflow-y: scroll;" data-page="profile">
					<h4 style="margin-bottom: 8px;">üîë Sucessfully logged in as <val id="profileName2"></val></h4>
					<r-close-icon onclick="loginPanel.style.display = 'none'" style="position: absolute; top: 10px; right: 10px;"></r-close-icon>
					<div style="flex-grow: 1">
						<h4>Profile</h4>
						<div class="reddit-card">
							<img id="profileImg" src="https://static.vecteezy.com/system/resources/thumbnails/009/292/244/small/default-avatar-icon-of-social-media-user-vector.jpg">
							<div class="profile-section" style="min-width: 164px;">
								<p id="profileName"></p>
								<div profileeditable noselect onmouseleave="profileDiscordEdit.style.display = 'none'">
									<img width="16" height="16" src="images/discord.png" id="profileDiscordIcon">
									<span>Discord: </span><a id="profileDiscord" href=""></a>
									<span onclick="profileDiscordEdit.style.display = profileDiscordEdit.style.display == 'none' ? 'block' : 'none'">
										<svg xmlns="http://www.w3.org/2000/svg" style="opacity: 0.2;cursor:pointer;" height="16" viewBox="0 96 960 960" width="16">
											<path d="M180 876h44l443-443-44-44-443 443v44Zm614-486L666 262l42-42q17-17 42-17t42 17l44 44q17 17 17 42t-17 42l-42 42Zm-42 42L248 936H120V808l504-504 128 128Zm-107-21-22-22 44 44-22-22Z"/>
										</svg>
									</span>
									<div id="profileDiscordEdit" style="display: none">
										<input type="text" class="reddit-modal-input" placeholder="Discord Snowflake/ID" id="profileDiscordInput">
										<button type="button" class="reddit-modal-button" style="padding: 6px;" id="profileDiscordSubmit">Update</button>
									</div>
								</div>
								<div profileeditable noselect onmouseleave="profileTwitterEdit.style.display = 'none'">
									<img width="16" height="16" src="images/twitter.png">
									<span>Twitter: </span><a id="profileTwitter" href=""></a>
									<span onclick="profileTwitterEdit.style.display = profileTwitterEdit.style.display == 'none' ? 'block' : 'none'">
										<svg xmlns="http://www.w3.org/2000/svg" style="opacity: 0.2;cursor:pointer;" height="16" viewBox="0 96 960 960" width="16">
											<path d="M180 876h44l443-443-44-44-443 443v44Zm614-486L666 262l42-42q17-17 42-17t42 17l44 44q17 17 17 42t-17 42l-42 42Zm-42 42L248 936H120V808l504-504 128 128Zm-107-21-22-22 44 44-22-22Z"/>
										</svg>
									</span>
									<div id="profileTwitterEdit" style="display: none">
										<input type="text" class="reddit-modal-input" placeholder="Twitter username" id="profileTwitterInput">
										<button type="button" class="reddit-modal-button" style="padding: 6px;" id="profileTwitterSubmit">Update</button>
									</div>
								</div>
								<div profileeditable noselect onmouseleave="profileRedditEdit.style.display = 'none';">
									<img width="16" height="16" src="images/reddit.png" id="profileRedditIcon">
									<span>Reddit: </span><a id="profileReddit" href=""></a>
									<span onclick="profileRedditEdit.style.display = profileRedditEdit.style.display == 'none' ? 'block' : 'none'">
										<svg xmlns="http://www.w3.org/2000/svg" style="opacity: 0.2;cursor:pointer;" height="16" viewBox="0 96 960 960" width="16">
											<path d="M180 876h44l443-443-44-44-443 443v44Zm614-486L666 262l42-42q17-17 42-17t42 17l44 44q17 17 17 42t-17 42l-42 42Zm-42 42L248 936H120V808l504-504 128 128Zm-107-21-22-22 44 44-22-22Z"/>
										</svg>
									</span>
									<div id="profileRedditEdit" style="display: none;">
										<input type="text" class="reddit-modal-input" placeholder="Reddit username" id="profileRedditInput">
										<button type="button" class="reddit-modal-button" style="padding: 6px;" id="profileRedditSubmit">Update</button>
									</div>
								</div>
							</div>
							<div style="width: 2px;background-color: #ccc;border-radius: 2px;"></div>
							<div class="profile-section">
								<p style="font-style: italic;">Stats</p>
								<div noselect><span>Pixels placed: </span><span id="profilePixels"></span></div>
								<div noselect><span>Join date: </span><span id="profileJoin"></span></div>
								<div noselect><span>Badges: </span><span id="profileBadges"></span></div>
							</div>
						</div>
						<h4>Account Data:</h4>
						<p>Account Tier: <span id="accountTier"></span></p>
						<p>Username: <span id="accountName"></span></p>
						<p>Email: <span id="accountEmail"></span></p>
						<a href="#">Instances: Go to instance manager</a>
					</div>
				</div>
			</div>
		</dialog>

		<div id="eventCountdown">
			<div class="announcer">
				<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="-300 -300 600 600" width="48" height="40">
					<circle r="292.3"></circle>
					<g style="fill:#f1cd43" transform="scale(0.9783764)">
						<circle r="50"></circle>
						<path d="M75,0A75,75 0 0,0 37.5-64.951905L125-216.50635A250,250 0 0,1 250,0Z" id="bld"></path>
						<use xlink:href="#bld" transform="rotate(120)"></use>
						<use xlink:href="#bld" transform="rotate(240)"></use>
					</g>
				</svg>
				<div class="countdown countdown-header">SPECIAL EVENT</div>
			</div>
			<div class="countdown">
				Event in 00:00:00
			</div>
			<div class="coverer">
				<img src="images/rplace.png" width="128" style="image-rendering: pixelated;">
				<span class="coverer-title">rplace.live</span>
				<span class="coverer-description">Special event</span>
			</div>
			<div class="progressbar"><!--progress bar--></div>
		</div>

		<dialog id="postRulesDialog" class="reddit-modal">
			<r-close-icon onclick="postRulesDialog.close()" style="position: absolute; top: 10px; right: 10px;"></r-close-icon>
			<div style="display: flex; flex-direction: column; padding: 16px; overflow-y: scroll; row-gap: 8px;">
				<h4>By creating a post, you agree to the following conditions:</h4>
				<ol style="font-size: 18px;line-height: 32px;margin-left: 16px; flex-grow: 1;">
					<li>All posts you create are public, and any information shared in a post will be visible to everyone.</li>
					<li>Your post must be related to rplace and must not contain NSFW or copyrighted content.</li>
					<li>All content uploaded may be processed by third party content filters and AI detection systems.</li>
					<li>Illegal content shall not be posted, and will be reported to relevant authorities, alongside any necessary user information to aid with investigation.</li>
				</ol>
				<img src="images/example-post.png" alt="Example post" style="height: 256px;object-fit: contain;">
				<button class="reddit-modal-button" onclick="
					localStorage.agredPostRules = true
					postRulesDialog.close(true)
					">Create post</button>    
			</div>
		</dialog>

		<dialog id="questsDialog" class="reddit-modal">
			<r-close-icon onclick="postRulesDialog.close()" style="position: absolute; top: 10px; right: 10px;"></r-close-icon>
			<div style="display: flex; flex-direction: column; padding: 16px; overflow-y: scroll; row-gap: 8px;">
				<h4>Quest complete! ü•≥</h4>
				<p id="questsDescription"><!--TODO: Flesh this out--></p>
				<img src="images/trophy.png" style="flex-grow: 1; object-fit: contain;">
				<button class="reddit-modal-button" onclick="questsDialog.close()">Close</button>
			</div>
		</dialog>
	</body>
	<script>
		let PALETTE_USABLE_REGION = { start: 0, end: 32 }
		let PALETTE = [0xff1a006d, 0xff3900be, 0xff0045ff, 0xff00a8ff, 0xff35d6ff, 0xffb8f8ff, 0xff68a300, 0xff78cc00, 0xff56ed7e, 0xff6f7500, 0xffaa9e00, 0xffc0cc00, 0xffa45024, 0xffea9036, 0xfff4e951, 0xffc13a49, 0xffff5c6a, 0xffffb394, 0xff9f1e81, 0xffc04ab4, 0xffffabe4, 0xff7f10de, 0xff8138ff, 0xffaa99ff, 0xff2f486d, 0xff26699c, 0xff70b4ff, 0xff000000, 0xff525251, 0xff908d89, 0xffd9d7d4, 0xffffffff]
		let WIDTH = 2000
		let HEIGHT = 2000
		let COOLDOWN = 10e3
	</script>
	<script>
		let moved = 3
		let touch1 = null
		let touch2 = null
		let touchmoved = 15

		// Bidirectional IPC, similar to server.ts - db-worker.ts communication
		// Methods called by posts frame 
		function resizePostsFrame() {
			const calcHeight = postsFrame.contentWindow.document.body.scrollHeight
			postsFrame.height = calcHeight 
			postsFrame.style.minHeight = calcHeight + "px" 
		}
		function openOverlayMenu() {
			overlayMenu.setAttribute("opened", "true")
		}
		let postsFrameReqId = 0
		let postsFrameReqs = new Map()
		async function makePostsFrameRequest(messageCall, args = undefined) {
			const handle = postsFrameReqId++
			const promise = new PublicPromise()
			const postCall = { call: messageCall, data: args, handle: handle }
			postsFrameReqs.set(handle, promise)
			postsFrame.contentWindow.postMessage(postCall)
			return await promise.promise
		}
		window.addEventListener("message", async function(event) {
			if (event.origin.startsWith("https://challenges.cloudflare.com")) {
				return
			}
			if (!event.origin.startsWith(location.origin)) {
				throw new Error("Invalid message origin")
			}
			const message = event.data
			if (message.call) { // Iframe asking to call window method
				let result = undefined
				if (window[message.call]) {
					result = await window[message.call](message.data)
				}
				if (message.handle !== undefined && message.handle !== null) {
					postsFrame.contentWindow.postMessage({ handle: message.handle, data: result })
				}
			}
			else { // Return value from iframe method
				postsFrameReqs.get(message.handle)?.resolve(message.data)
			}
		})
		function sendPostsFrameMessage(messageCall, args = undefined) {
			postsFrame.contentWindow.postMessage({ call: messageCall, data: args })
		}

		// Load more posts on scroll down
		more.addEventListener("scroll", function(e) {
		    const moreMaxScroll = more.scrollHeight - more.clientHeight
			if (moreMaxScroll - more.scrollTop < 256) {
				sendPostsFrameMessage("tryLoadBottomPosts")
			}
			// Dialog positioning is messed up as it only sees iframe window, this is cursed but it works
			const dialogTopHeight = Math.max(more.scrollTop - spaceFiller.offsetHeight + window.innerHeight / 2,
				spaceFiller.offsetHeight)
			sendPostsFrameMessage("updateDialogTop", dialogTopHeight)
		}, { passive: true })

		document.body.ontouchstart = function(e) {
			for (let t of e.changedTouches) {
				if (!touch1) touch1 = t, touchmoved = 15
				else if (!touch2) touch2 = t
				else [touch1, touch2] = [touch2, t]
			}
		}

		document.body.onmousedown = function(e) {
			moved = 3
			mouseDown = e.button + 1
		}

		document.onmouseup = function(e) {
			if (e.target != maincontent && !canvparent2.contains(e.target)) {
				return (moved = 3, mouseDown = 0)
			}

			if (moved > 0 && canvparent2.contains(e.target)) {
				clicked(e.clientX, e.clientY)
			}

			moved = 3
			mouseDown = 0
		}

		let arrowkeyDown = {
			left: false,
			right: false,
			up: false,
			down: false
		}

		let selX = 0
		let selY = 0
		const canvasCtx = canvas.getContext('2d')
		function transform() {
			const scale = z * 50;
			const translateX = x * z * -50;
			const translateY = y * z * -50;
			const width = z * canvas.width * 50;
			const height = z * canvas.height * 50;

			canvparent1.style.transform = `translate(${translateX + innerWidth / 2}px, ${translateY + maincontent.offsetHeight / 2}px) scale(${scale})`;
			canvparent2.style.transform = canvparent1.style.transform;
			canvselect.style.transform = `translate(${Math.floor(x)}px, ${Math.floor(y)}px) scale(0.01)`;
			canvas.style.width = `${width}px`;
			canvas.style.height = `${height}px`;
			canvas.style.transform = `translate(${translateX}px, ${translateY}px)`;
			canvas.style.imageRendering = z < 1 / 50 / devicePixelRatio ? "initial" : "";
		}

		// Essential game variable definitions
		let x, y, z, board, minZoom;

		function showLoadingScreen() {
			loadingScreen.style.opacity = 1
			loadingScreen.style.display = "flex"
			waitingGame.start()
		}

		function hideLoadingScreen() {
			loadingScreen.style.opacity = 0
			setTimeout(() => loadingScreen.style.display = "none", 300)
			setTimeout(() => waitingGame.stop(), 300)
		}

		class WaitingGame {
			constructor(canvas) {
				this.canvas = canvas
				this.started = false
				this.ctx = canvas.getContext("2d")
			}

			start() {
				if (this.started) return
				this.canvas.width = innerWidth
				this.canvas.height = innerHeight
				this.context = this.canvas.getContext("2d")
				this.interval = setInterval(() => {
					waitingGame.clear()
					for (const cube of physicsCubes) {
						cube.update()
					}
				}, 16)
				this.started = true
			}

			stop() {
				clearInterval(this.interval)
				physicsCubes = []
				this.clear()
				this.started = false
			}

			clear() {
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
			}
		}

		class Component {
			constructor(width, height, colour, x, y, waitingGame) {
				this.width = width
				this.height = height
				this.x = x
				this.y = y
				this.speedX = 0
				this.speedY = 0
				this.gravity = 0.36
				this.gravitySpeed = 0
				this.colour = colour
				this.waitingGame = waitingGame
			}

			update() {
				//gravity calculations
				this.gravitySpeed += this.gravity
				this.y += (waitingGame.canvas.height - this.y > 30) ? (this.speedY + this.gravitySpeed) : 0
				this.x += this.speedX

				//floor
				const floor = waitingGame.canvas.height - this.height
				if (this.y > floor) {
					this.y = floor
					this.speedY = 0
					this.gravitySpeed = 0
				}

				//grid snap
				this.x = Math.floor(this.x / this.width) * this.width

				//overlapping
				for (const other of physicsCubes) {
					if (other != this) {
						let calcH = (this.height + other.height) / 2, calcW = (this.width + other.width) / 2
						if (Math.abs(this.y - other.y) < calcH && Math.abs(other.x - this.x) < calcW) { //Colliding
							this.speedY = 0
							this.gravitySpeed = 0
							this.y = (other.y - other.height) - 0.01
						}
					}
				}

				//render update
				this.waitingGame.ctx.fillStyle = this.colour
				this.waitingGame.ctx.fillRect(this.x, this.y, this.width, this.height)
			}
		}

		let physicsCubes = []
		const waitingGame = new WaitingGame(waitingGameCanvas)
		waitingGame.canvas.onmousedown = function(event) {
			physicsCubes.push(new Component(80, 80, ["grey", "lightgray", "darkgray", "whiteSmoke"][Math.floor(Math.random() * 4)], Math.floor(event.x), Math.floor(event.y), waitingGame))
		}
		showLoadingScreen()

		function setSize(w, h = w) {
			canvas.width = WIDTH = w
			canvas.height = HEIGHT = h
			canvparent1.style.width = w + "px"
			canvparent1.style.height = h + "px"
			canvparent2.style.width = w + "px"
			canvparent2.style.height = h + "px"
			board = new Uint8Array(w * h).fill(255)
			let i = board.length
			x = +localStorage.x || WIDTH / 2
			y = +localStorage.y || HEIGHT / 2
			z = +localStorage.z || 0.2

			for (let [key, value] of new URLSearchParams(location.search)) {
				switch (key) { // Only for numeric value params
					case "x": x = +value || 0; pos(); break
					case "y": y = +value || 0; pos(); break
					case "z": z = +value || 0; break
					case "err": onerror = alert; break
					case "overlay":
						overlayInfo = JSON.parse(atob(value))
						const decoded = atob(overlayInfo.data)
						const data = new Uint8Array(new ArrayBuffer(decoded.length))
						for (let i = 0; i < decoded.length; i++) data[i] = decoded.charCodeAt(i)

						templateImage.src = window.URL.createObjectURL(new Blob([data]), { type: overlayInfo.type })
						overlayInfo.x = +overlayInfo.x || 0
						overlayInfo.y = +overlayInfo.y || 0
						templateImage.style.transform = `translate(${overlayInfo.x}px, ${overlayInfo.y}px)`
						templateImage.style.opacity = +overlayInfo.opacity || 0.8
						x = overlayInfo.x
						y = overlayInfo.y
						pos()
						overlayMenu.setAttribute('opened', 'true')
						break
				}
			}
			onresize()
		}

		onresize = function() {
			minZoom = Math.min(innerWidth / canvas.width, maincontent.offsetHeight / canvas.height) / 100
			pos()
			waitingGame.canvas.width = innerWidth
			waitingGame.canvas.height = maincontent.offsetHeight
		}

		let lastMouseMove = 0
		let mouseDown = false
		let mx = 0
		let my = 0

		document.body.onmousemove = function(e) {
			lastMouseMove = Date.now()
			if (e.target != maincontent && !canvparent2.contains(e.target)) {
				return
			}
			moved--
			let dx = -(mx - (mx = e.clientX - innerWidth / 2))
			let dy = -(my - (my = e.clientY - maincontent.offsetHeight / 2))
			if (dx != dx || dy != dy) {
				return
			}
			if (mouseDown) {
				x -= dx / (z * 50)
				y -= dy / (z * 50)
				pos()
				clearInterval(anim)
			}
		}
		document.body.onwheel = function(e) {
			if (e.target != maincontent && !canvparent2.contains(e.target)) {
				return
			}
			let d = Math.max(minZoom / z, Math.min(3 ** Math.max(-0.5, Math.min(0.5, e.deltaY * -0.01)), 1 / z))
			z *= d
			x += mx * (d - 1) / z / 50
			y += my * (d - 1) / z / 50
			pos()
		}

		let idPositionDebounce = false
		let idPositionTimeout = -1
		let lastIntX = Math.floor(x)
		let lastIntY = Math.floor(y)

		function pos() {
			z = Math.min(Math.max(z, minZoom), 1)

			const right = x - canvas.width + 0.01
			const left = x
			const up = y - canvas.height + 0.01
			const down = y

			if (right >= left) x = 0
			else if (right > 0) x -= right
			else if (left < 0) x -= left
			if (up >= down) y = 0
			else if (up > 0) y -= up
			else if (down < 0) y -= down
			posel.textContent = `(${Math.floor(x)},${Math.floor(y)}) ${z > 0.02 ? Math.round(z*50)/10 : Math.ceil(z*500)/100}x`
			localStorage.x = Math.floor(x) + 0.5
			localStorage.y = Math.floor(y) + 0.5
			localStorage.z = z
			transform()

			const intX = Math.floor(x), intY = Math.floor(y)
			if (intX != lastIntX || intY != lastIntY) {
				clearTimeout(idPositionTimeout)
				idPosition.style.display = "none"
				idPositionDebounce = false
			}
			lastIntX = intX
			lastIntY = intY

			if (!idPositionDebounce) {
				idPositionDebounce = true

				idPositionTimeout = setTimeout(() => {
					idPositionDebounce = false
					let id = intIdPositions.get(intX + intY * WIDTH)
					if (id === undefined || id === null) {
						// Request 16x16 region of pixel placers from server (fine tune if necessary)
						const placersRadius = 16
						requestPixelPlacers(Math.max(intX - placersRadius / 2, 0), Math.max(intY - placersRadius / 2),
							Math.min(placersRadius, WIDTH - intX), Math.min(placersRadius, HEIGHT - intY))
						return
					}
					idPosition.style.display = "flex"
					idPosition.style.left = intX + "px"
					idPosition.style.top = intY + "px"
					idPosition.children[1].style.color = CHAT_COLOURS[hash("" + id) & 7]
					idPosition.children[1].textContent = intIdNames.get(id) || ("#" + id)
				}, 1000)
			}
		}

		let boardAlreadyRendered = false
		function renderAll() {
			const img = new ImageData(canvas.width, canvas.height)
			const data = new Uint32Array(img.data.buffer)
			for (let i = 0; i < board.length; i++) {
				data[i] = PALETTE[board[i]]
			}

			canvasCtx.putImageData(img, 0, 0)
			// Workaround for blank-canvas bug on chrome on M1 chips
			canvasCtx.getImageData(0, 0, 1, 1)
			boardAlreadyRendered = true
		}

		let xa = new Uint32Array(1)
		let xb = new Uint8Array(xa.buffer)

		function set(x, y, b) {
			board[x % canvas.width + (y % canvas.height) * canvas.width] = b
			xa[0] = PALETTE[b]
			canvasCtx.fillStyle = "#" + (xb[0] < 16 ? "0" : "") + xb[0].toString(16) + (xb[1] < 16 ? "0" : "") + xb[1].toString(16) + (xb[2] < 16 ? "0" : "") + xb[2].toString(16) + (xb[3] < 16 ? "0" : "") + xb[3].toString(16)
			canvasCtx.clearRect(x, y, 1, 1)
			canvasCtx.fillRect(x, y, 1, 1)
		}

		document.body.ontouchmove = e => {
			for (let t of e.changedTouches) {
				clearInterval(anim)
				a: if (!touch2 && touch1 && touch1.identifier == t.identifier) {
					touchmoved -= Math.abs(t.clientY - touch1.clientY) + Math.abs(t.clientX - touch1.clientX)
					if (e.target != maincontent && !canvparent2.contains(e.target)) break a
					x -= (t.clientX - touch1.clientX) / (z * 50)
					y -= (t.clientY - touch1.clientY) / (z * 50)
					pos()
				}
				else if (touch1 && touch2) {
					if (e.target != maincontent && !canvparent2.contains(e.target)) break a
					let touch = touch1.identifier == t.identifier ? touch1 : (touch2.identifier == t.identifier ? touch2 : null)
					if (!touch) break a
					let other = touch == touch1 ? touch2 : touch1
					x -= (t.clientX - touch.clientX) / (z * 50)
					y -= (t.clientY - touch.clientY) / (z * 50)
					touchmoved -= Math.abs(t.clientY - touch.clientY) + Math.abs(t.clientX - touch.clientX)
					let dx = touch.clientX - other.clientX
					let dy = touch.clientY - other.clientY
					let a = dx * dx + dy * dy
					dx = t.clientX - other.clientX
					dy = t.clientY - other.clientY
					a = Math.sqrt((dx * dx + dy * dy) / a)
					z *= a
					pos()
				}
				if (touch1 && touch1.identifier == t.identifier) touch1 = t
				else if (touch2 && touch2.identifier == t.identifier) touch2 = t
			}
		}

		// Blank default render and canvas size init before we have loaded board
		setSize(WIDTH, HEIGHT)
		renderAll()
		let anim = null

		function clicked(clientX, clientY) {
			clearInterval(anim)
			clientX = Math.floor(x + (clientX - innerWidth / 2) / z / 50) + 0.5
			clientY = Math.floor(y + (clientY - maincontent.offsetHeight / 2) / z / 50) + 0.5
			if (clientX == Math.floor(x) + 0.5 && clientY == Math.floor(y) + 0.5) {
				clientX -= 0.5;
				clientY -= 0.5
				if (CD < Date.now()) {
					zoomIn()
					showPalette()
				} else {
					AUDIOS.invalid.run()
				}
				return
			}
			(CD > Date.now() ? AUDIOS.invalid : AUDIOS.highlight).run()
			anim = setInterval(function() {
				x += (clientX - x) / 10
				y += (clientY - y) / 10
				pos()
				if (Math.abs(clientX - x) + Math.abs(clientY - y) < 0.1) clearInterval(anim)
			}, 15)
		}

		function zoomIn() {
			if (z >= 0.4) return
			clearInterval(anim)
			let dz = 0.005
			anim = setInterval(function() {
				if (dz < 0.2) dz *= 1.1
				z *= 1 + dz
				pos()
				if (z >= 0.4) clearInterval(anim)
			}, 15)
		}

		HTMLAudioElement.prototype.run = Audio.prototype.run = async function() {
			if (muted) return
			this.currentTime = 0
			this.play().catch(e => e)
		}

		const localStorageBoolValues = [ undefined, "true", "false" ]
		if (!localStorageBoolValues.includes(localStorage.muted)) {
			localStorage.muted = "false"
		}
		if (!localStorageBoolValues.includes(localStorage.placeChat)) {
			localStorage.placeChat = "true"
		}
		let muted = localStorage.muted === "true"
		let placeChat = localStorage.placeChat === "true"
		let onCooldown = false
		let PEN = -1
		let CD = null
		let initialConnect = false

		mutesvg.innerHTML = muted ? MUTED_SVG : UNMUTED_SVG
		placeChatButton.children[0].style.opacity = placeChat ? '1' : '0.6'

		setInterval(() => {
			let left = Math.floor((CD - Date.now()) / 1000)
			place.innerHTML = initialConnect
				? CD === null // They have made initial connect
					? `<span style="color:#f50; white-space: nowrap;">${translate("connectingFail")}</span>` // They connected but now have disconnected
					: left > 0
						? `<svg xmlns="http://www.w3.org/2000/svg" data-name="icons final" viewBox="0 0 20 20" style="height: 1.1rem;vertical-align:top"><path d="M13.558 14.442l-4.183-4.183V4h1.25v5.741l3.817 3.817-.884.884z"></path><path d="M10 19.625A9.625 9.625 0 1119.625 10 9.636 9.636 0 0110 19.625zm0-18A8.375 8.375 0 1018.375 10 8.384 8.384 0 0010 1.625z"></path></svg> ${
								("" + Math.floor(left/3600)).padStart(2, "0")}:${("" + Math.floor((left / 60)) % 60).padStart(2, "0")}:${("" + left % 60).padStart(2, "0")}` // They are connected + still connected but in cooldown
						: translate("placeTile") // They are connected + still connected + after cooldown
				: translate("connecting") // They are yet to connect

			if (CD > Date.now() && !onCooldown) {
				onCooldown = true
			}
			if (CD < Date.now() && onCooldown) {
				onCooldown = false
				if (!document.hasFocus()) AUDIOS.cooldownEnd.run()
			}
		}, 200)

		function showPalette() {
			palette.style.transform = ""
			AUDIOS.highlight.run()
		}

		function generatePalette() {
			colours.innerHTML = ""
			for (let i = PALETTE_USABLE_REGION.start; i < PALETTE_USABLE_REGION.end; i++) {
				const colour = PALETTE[i]
				const colourEl = document.createElement("div")
				colourEl.dataset.index = i
				colourEl.style.background = `rgba(${colour & 255},${(colour >> 8) & 255},${(colour >> 16) & 255}, 1)`
				if (colour == 0xffffffff) {
					colourEl.style.outline = "1px #ddd solid"
					colourEl.style.outlineOffset = "-1px"
				}
				const indicatorSpan = document.createElement("span")
				indicatorSpan.contentEditable = true
				indicatorSpan.onkeydown = function(event) {
					rebindIndicator(event, i)
				}
				colourEl.appendChild(indicatorSpan)
				colours.appendChild(colourEl)
			}
		}
		generatePalette()

		colours.onclick = (e) => {
			const clickedColour = e.target
			if (!clickedColour || !clickedColour.dataset.index) {
				return
			}
			const i = parseInt(clickedColour.dataset.index)
			if (Number.isNaN(i) || i < PALETTE_USABLE_REGION.start || i >= PALETTE_USABLE_REGION.end) {
				return
			}
			for (const colour of colours.children) {
				colour.classList.remove("sel")
			} 
			PEN = i
			canvselect.style.background = e.target.style.background
			e.target.classList.add("sel")
			pok.classList.add("enabled")
			canvselect.children[0].style.display = "none"
			canvselect.style.outline = "8px white solid"
			canvselect.style.boxShadow = "0px 2px 4px 0px rgb(0 0 0 / 50%)"
			hideIndicators()
			AUDIOS.selectColour.run()
		}

		function runLengthChanges(data, buffer) {
			let i = 9,
			boardI = 0
			let w = data.getUint32(1), h = data.getUint32(5)
			if (w != WIDTH || h != HEIGHT) setSize(w, h)
			board = new Uint8Array(buffer)
			while (i < data.byteLength) {
				let cell = data.getUint8(i++)
				let c = cell >> 6
				if (c == 1) c = data.getUint8(i++)
				else if (c == 2) c = data.getUint16(i++), i++
				else if (c == 3) c = data.getUint32(i++), i += 3
				boardI += c
				board[boardI++] = cell & 63
			}
			renderAll()
		}

		// The new server's equivalent for run length changes, based upon run length encoding
		function runLengthDecodeBoard(data, length) {
			data = new Uint8Array(data)
			board = new Uint8Array(length)
			let boardI = 0
			let colour = 0

			for (let i = 0; i < data.byteLength; i++) {
				// Then it is a palette value
				if (i % 2 == 0) {
					colour = data[i]
					continue
				}
				// After colour, loop until we unpack all repeats, byte can only hold max 255,
				// so we add one to repeated data[i], and treat it as if 0 = 1 (+1)
				for (let j = 0; j < data[i] + 1; j++) {
					board[boardI] = colour
					boardI++
				}
			}
			renderAll()
		}

		const encoder = new TextEncoder()
		const decoder = new TextDecoder()
		const allowed = ["rplace.tk", "rplace.live", "google.com", "wikipedia.org", "pxls.space"]
		const webGLSupported = (() => {
			let supported = true
			const glTestCanvas = document.createElement("canvas")
			try { supported = glTestCanvas.getContext("webgl2") !== null }
			catch(e) { supported = false }
			return supported
		})();
		if (!webGLSupported) {
			console.error("Client doesn't support WebGL! Some site features may break!")
		}
		const mobile = window.matchMedia("(orientation: portrait)").matches
		const hash = (text) => text.split("").reduce((hash, char) => (hash * 31 + char.charCodeAt()) >>> 0, 0)
		let online = 1
		let extraLanguage = (lang == "en" ? "tr" : lang)
		let cMessages = { [extraLanguage]: [], en: [] }
		let chatPreviousLoadDebounce = false
		let chatPreviousAutoLoad = false
		let currentChannel = lang
		let fetchCooldown = 500, fetchFailTimeout = -1
		extraChannel(extraLanguage)
		initChannelDrop()
		switchLanguageChannel(currentChannel)
		wscapsule()

		async function fetchBoard() {
			// Override browser cache with ?v= param, may incurr longer loading times
			// TODO: investigate optimisations to onl;y do a hard realod when necessary
			const response = await fetch((localStorage.board || DEFAULT_BOARD) + "?v=" + Date.now())
			if (!response.ok) {
				showLoadingScreen()
				fetchFailTimeout = setTimeout(fetchBoard, fetchCooldown *= 2)
				if (fetchCooldown > 8000) {
					loadingScreen.children[0].src = "images/rplace-offline.png"
					clearTimeout(fetchFailTimeout)
				}

				return null
			}

			if (fetchFailTimeout != -1) clearTimeout(fetchFailTimeout)
			return await response.arrayBuffer()
		}

		// We don't await this yet, when the changes (old server) / canvas width & height (new server) packet
		// comes through, it will await this unawaited state until it is fufilled, so we are sure we have all the data
		let preloadedBoard = fetchBoard()

		function seti(i, b) {
			board[i] = b
			xa[0] = PALETTE[b]
			canvasCtx.fillStyle = "#" + (xb[0] < 16 ? "0" : "") + xb[0].toString(16) + (xb[1] < 16 ? "0" : "") + xb[1].toString(16) + (xb[2] < 16 ? "0" : "") + xb[2].toString(16) + (xb[3] < 16 ? "0" : "") + xb[3].toString(16)
			canvasCtx.fillRect(i % WIDTH, Math.floor(i / WIDTH), 1, 1)
		}

		function hideIndicators() {
			for (let c = 0; c < colours.children.length; c++) {
				colours.children[c].firstChild.style.visibility = "hidden"
			}
		}

		function rebindIndicator(e, i) {
			if (!e.key || e.key.length != 1) return
			e.target.innerText = e.key
			e.target.blur()

			let binds = (localStorage.paletteKeys || DEFAULT_PALETTE_KEYS).split("")
			let preexisting = binds.indexOf(e.key)
			if (preexisting != -1) binds[preexisting] = "‚Äã"
			binds[i] = e.key.charAt(0)
			localStorage.paletteKeys = binds.join("")
			generateIndicators(binds.join(""))
		}
		function generateIndicators(keybinds) {
			for (let c = 0; c < colours.children.length; c++) {
				let indicator = colours.children[c].firstChild
				indicator.textContent = keybinds?.charAt(c)
			}
		}
		generateIndicators(localStorage.paletteKeys || DEFAULT_PALETTE_KEYS)

		if (chatName) {
			namePanel.style.visibility = "hidden"
		}

		function initChannelDrop() {
			let containsMy = false

			channelDrop.children[0].innerHTML = ""
			for (let [code, info] of LANG_INFOS) {
				if (code == lang) containsMy = true
				let el = document.createElement("li")
				el.innerHTML = `<span>${info.name}</span> <img src="${info.flag}" style="height: 24px;">`
				el["lang"] = code
				channelDrop.children[0].appendChild(el)
			}

			if (!containsMy) {
				let el = document.createElement("li")
				el.innerHTML = `<span>${lang}</span>`
				el["lang"] = lang
				channelDrop.children[0].appendChild(el)
			}
		}

		function extraChannel(code) {
			// TODO: Implement if persisting all channels becomes too heavy
			// delete cMessages[extraLanguage]
			let info = LANG_INFOS.get(code)
			channelMineName.innerText = code.toUpperCase()
			channelMineImg.src = info?.flag
			channelMineImg.style.display = ((info?.flag) ? "inline" : "none")
			extraLanguage = code
			cMessages[code] ||= []
		}

		function switchLanguageChannel(selected) {
			channelMine.style.opacity = "0.5"
			channelEn.style.opacity = "0.5"
			if (currentChannel != selected) chatCancelReplies()
			currentChannel = selected
			chatMessages.style.direction = (LANG_INFOS.get(selected)?.rtl) ? "rtl" : "ltr"

			if (selected == "en")
				channelEn.style.opacity = "1"
			else if (selected == extraLanguage)
				channelMine.style.opacity = "1"

			chatMessages.innerHTML = ""
			// User must ask to load previous at least once for each channel before site
			// will start auto loading previous chat messages
			chatPreviousAutoLoad = false
			if (cMessages[selected]?.length) {
				for (const el of cMessages[selected]) {
					chatMessages.appendChild(el)
				}
			}
			else if (typeof requestLoadChannelPrevious === "function") {
				// If we don't have any cached messages for this channel, try pre-populate with a few
				requestLoadChannelPrevious(32)
			}
		}

		/* @return {Element | HTMLCollection} */ 
		function stringToHtml(html, trim = true) {
			const template = document.createElement("template")
			template.innerHTML = html
			const result = template.content.children
			return result.length === 1 ? result[0] : result
		}

		function chatMentionUser(senderId) {
			let [start, end] = [messageInput.selectionStart, messageInput.selectionEnd]
			let mentionText = "@"
			const identifier = intIdNames.get(senderId) || ("#" + senderId)
			if (typeof identifier === "string") {
				mentionText += identifier
			}
			else if (typeof identifier === "number") {
				mentionText += "#" + identifier
			}
			messageInput.setRangeText(mentionText, start, end, "end")
			messageInput.focus()
		}

		function chatReply(messageId, senderId) {
			for (let m of cMessages[currentChannel]) {
				m.removeAttribute("reply")
			}
			currentReply = messageId

			// HACK: Ensure no overlap between reply and send features
			messageTypePanel.style.height = "calc(var(--message-input-height) + 92px)"
			messageInput.focus()
			messageReplyPanel.removeAttribute("closed")
			messageReplyLabel.innerText = translate("replyTo") + ": " + (intIdNames.get(senderId) || ("#" + senderId))
			for (let m of cMessages[currentChannel]) {
				if (m["messageId"] == messageId) {
					m.setAttribute("reply", "true")
					break
				}
			}
		}

		function chatCancelReplies() {
			for (let m of cMessages[currentChannel]) {
				m.removeAttribute("reply")
			}
			currentReply = null
			// HACK: Ensure no overlap between reply and send features
			messageTypePanel.style.height = "calc(var(--message-input-height) + 62px)"
			messageReplyPanel.setAttribute('closed', 'true')
		}

		function clearChatModerate() {
			modMessageId.value = ""
			modMessagePreview.innerHTML = ""
			modDurationH.value = null
			modDurationM.value = null
			modDurationS.value = null
			modAffectsAll.checked = false
			modReason.value = ""
		}

		function closeChatModerate() {
			moderationMenu.removeAttribute('opened')
			clearChatModerate()
		}

		// Mode: string ("delete"|"kick"|"mute"|"ban"|"captcha")
		function chatModerate(mode, senderId, messageId = null, messageElement = null) {
			clearChatModerate()
			modMemberId.value = senderId
			modMessageId.value = messageId
			moderationMenu.setAttribute("opened", "true")
			moderationMenu.setAttribute("mode", mode)
			modMessagePreview.innerHTML = messageElement?.innerHTML

			switch(mode) {
				case "delete":
					modActionDelete.checked = true
					break
				case "kick":
					modActionKick.checked = true
					break
				case "mute":
					modActionMute.checked = true
					break
				case "ban":
					modActionBan.checked = true
					break
				case "captcha":
					modActionCaptcha.checked = true
					break
			}
		}

		function closeMessageEmojisPanel() {
			messageEmojisPanel.setAttribute("closed", "true")
			messageInput.setAttribute("state", "default")
		}

		let messageInputHeight = messageInput.scrollHeight
		function updateMessageInputHeight() {
			messageInput.style.height = "0px"
			const oldHeight = messageInputHeight
			messageInputHeight = Math.min(messageInput.scrollHeight, 256)
			chatPanel.style.setProperty("--message-input-height", messageInputHeight + "px")
			messageInput.style.height = "" // unset
			const diffHeight = messageInputHeight - oldHeight
			chatMessages.scrollBy(0, diffHeight)
		}

		messageInput.oninput = e => {
			if (!e.isTrusted) return
			updateMessageInputHeight()

			messageEmojisPanel.innerHTML = ""
			let comp = ""
			let search = true
			let count = 0
			for (let i = messageInput.value.length - 1; i >= 0; i--) {
				// No emoji code will ever have a space before we reach the opening : (going backwards
				// through string) so we can guess to just stop if seen as we backtrack
				if (messageInput.value[i] == " " && search) {
					comp = ""
					break
				}
				else if (messageInput.value[i] == ":") {
					count++
					search = false
				}
				if (search) {
					comp = messageInput.value[i] + comp
				}
			}
			//All : already closed, they are probably not trying to do an emoji so we ignore
			if (count % 2 == 0) comp = ""

			if (comp) {
				messageInput.setAttribute("state", "command")
			}
			else {
				closeMessageEmojisPanel()
			}

			function createEmojiEntry(emojiCode) {
				const entryElement = document.createElement("button")
				entryElement.classList.add("message-emojis-suggestion")
				entryElement.title = `Send this emoji in chat with :${emojiCode}:`
				const entryLabel = document.createElement("span")
				entryLabel.textContent = `:${emojiCode}:`
				entryElement.appendChild(entryLabel)
				return entryElement
			}

			let handled = false
			for (const [emojiCode, value] of Object.entries(EMOJIS)) {
				if (comp && emojiCode.startsWith(comp)) {
					const entryElement = createEmojiEntry(emojiCode)
					const entryValueText = document.createTextNode(value)
					entryElement.appendChild(entryValueText)
					entryElement.addEventListener("click", function() {
						for (let i = messageInput.value.length - 1; i >= 0; i--) {
							if (messageInput.value[i] == ":") {
								messageInput.value = messageInput.value.slice(0, i) + value
								closeMessageEmojisPanel()
								break
							}
						}
					})
					messageEmojisPanel.appendChild(entryElement)
					messageEmojisPanel.removeAttribute("closed")
				}

				if (messageInput.value.includes(":" + emojiCode + ":")) {
					messageInput.value = messageInput.value.replace(":" + emojiCode + ":", value)
					messageInput.setAttribute("state", "default")
					handled = true
				}
			}
			if (!handled) for (const [emojiCode, value] of Object.entries(EMOJIS_CUSTOM)) {
				if (comp && emojiCode.startsWith(comp)) {
					const entryElement = createEmojiEntry(emojiCode)
					entryElement.appendChild(stringToHtml(value))
					entryElement.addEventListener("click", function() {
						for (let i = messageInput.value.length - 1; i >= 0; i--) {
							if (messageInput.value[i] == ":") {
								messageInput.value = messageInput.value.slice(0, i) + ":" + emojiCode + ":"
								closeMessageEmojisPanel()
								break
							}
						}
					})
					messageEmojisPanel.appendChild(entryElement)
					messageEmojisPanel.removeAttribute("closed")
				}

				if (messageInput.value.includes(":" + emojiCode + ":")) {
					messageInput.setAttribute("state", "default")
					handled = true
				}
			}
		}

		function switchGameServer(serverAddress) {
			if (serverAddress) {
				let [a, b] = serverAddress.split(" ").reverse()
				if (!b)[b, a] = [a + '/place', 'server.' + a]
				a = "wss://" + a
				b = "https://" + b
				server(a, b)
			}
			else {
				delete localStorage.board
				delete localStorage.server
			}
			let queries = location.toString().split('?')
			if (queries.length > 1)
				location.replace(location.toString().split('?')[0], false)
			else
				location += ""
		}

		function server(serverAddress, boardAddress, vip = "", storage = localStorage) {
			if (!serverAddress) {
				storage.vip = storage.vip2
				delete storage.vip2
				delete storage.server
				delete storage.board
				return
			}

			storage.vip2 = storage.vip2 || storage.vip
			storage.vip = vip
			storage.server = serverAddress
			storage.board = boardAddress
		}

		let styleElement = null
		let currentTheme = null
		async function theme(themeSet, variant = null, effects=null) {
			variant ??= ""

			// Effects
			disableDarkplace()
			disableWinter()
			switch (effects) {
				case "darkplace":
					enableDarkplace()
					break
				case "winter":
					enableWinter()
					break
			}

			if (currentTheme !== themeSet) {
				// Intermediate stylesheet handles giving a nice transition animation during theme change
				const intermediate = document.createElement("link")
				intermediate.rel = "stylesheet"
				intermediate.type = "text/css"
				intermediate.href = "theme-switch.css"
				intermediate.setAttribute("intermediate-temp", "true")
				await (new Promise(resolve => {
					intermediate.onload = resolve
					document.head.appendChild(intermediate)
				}))
				// Load in new CSS
				const link = document.createElement("link")
				link.rel = "stylesheet"
				link.type = "text/css"
				link.href = themeSet.css + "?v=" + themeSet.cssVersion
				await (new Promise(async (resolve) => {
					link.onload = resolve
					document.head.appendChild(link)
				}))
				setTimeout(() => document.head.removeChild(intermediate), 200)
				// Swap out intermediate and old stylesheet
				if (styleElement) document.head.removeChild(styleElement)
				styleElement = link
				currentTheme = themeSet

				document.querySelectorAll("[theme]").forEach((element) => {
					if (element.tagName == "IMG") {
						element.src = themeSet[element.getAttribute("theme")] || element.src
					}
					else {
						element.innerHTML = themeSet[element.getAttribute("theme")] || element.innerHTML
					}
				})
				document.documentElement.dataset.theme = themeSet.id
			}
			document.documentElement.dataset.variant = variant
		}
		const startupThemeSet = DEFAULT_THEMES.get(localStorage.theme || "r/place 2022")
		theme(startupThemeSet, localStorage.variant, localStorage.effects)
		themeDropName.textContent = "üñåÔ∏è " + (localStorage.theme || "r/place 2022")

		function translateAll() {
			document.querySelectorAll("[translate]").forEach((element) => {
				let key = element.getAttribute("translate")
				if (TRANSLATIONS[lang] == null) return
				if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {
					if (element.getAttribute("type") == "text")
						element.placeholder = TRANSLATIONS[lang][key] || element.placeholder
					else
						element.value = TRANSLATIONS[lang][key] || element.value
				}
				else
					element.innerHTML = TRANSLATIONS[lang][key] || element.innerHTML
			})
		}
		translateAll()

		const clamp = (num, min, max) => Math.min(Math.max(num, min), max)

		function tlMouseMove(e) {
			if (!tlSelect.getAttribute('dragging') == "true") {
				tlSelect.style.cursor = "default"
				return
			}
			tlSelect.style.left = clamp(e.clientX - tlImage.getBoundingClientRect().left, 0, WIDTH - tlSelect.style.width) + "px"
			tlSelect.style.top = clamp(e.clientY - tlImage.getBoundingClientRect().top, 0, HEIGHT - tlSelect.style.height) + "px"
			tlSelect.style.cursor = "all-scroll"
		}

		function toggleTlPanel() {
			timelapsePanel.style.display = timelapsePanel.style.display == 'none' ? 'block' : 'none'
			tlImage.src = canvas.toDataURL("image/png")
			tlSelect.style.width = WIDTH + "px"
			tlSelect.style.height = HEIGHT + "px"

			let backups = []
			fetch(localStorage.board + '/backuplist')
				.then((response) => response.text())
				.then((data) => {
					for (let b of data.split("\n")) backups.push(b)
				})
				.then(() => {
					VirtualSelect.init({
						ele: '#tlStartSel',
						placeholder: "Select timelapse start backup",
						search: true,
						options: backups,
					})
					VirtualSelect.init({
						ele: '#tlEndSel',
						placeholder: "Select timelapse end backup",
						search: true,
						options: backups,
					})
				})
		}

		let tlTimerStart
		function confirmTlCreate() {
			tlConfirm.value = "Timelapse loading. Hang tight! ‚è≥"
			tlConfirm.style.pointerEvents = "none"
			tlTimerStart = Date.now()
			let tlTimerInterval = setInterval(updateTlTimer, 100)

			fetch(`https://${localStorage.server || DEFAULT_SERVER}/timelapse/`, {
					method: "POST",
					body: JSON.stringify({
						"backupStart": tlStartSel.value,
						"backupEnd": tlEndSel.value,
						"fps": Number(tlFps.value),
						"startX": 0,
						"startY": 0,
						"endX": WIDTH,
						"endY": HEIGHT,
						"reverse": tlPlayDir.getAttribute('reverse') == "true"
					}),
					headers: { 'Content-type': 'application/json; charset=UTF-8' }
				})
				.then(resp => resp.blob())
				.then(blob => {
					const url = window.URL.createObjectURL(blob)
					const a = document.createElement('a')
					a.style.display = 'none'
					a.href = url
					a.download = 'place_timelapse.gif'
					document.body.appendChild(a)
					a.click()
					tlConfirm.value = "Create"
					tlConfirm.style.pointerEvents = "auto"
					clearInterval(tlTimerInterval)
					tlTimer.innerText = "0.0s"
				})
				.catch((e) => {
					console.log("Timelapse failed, " + e)
					tlConfirm.value = "Create"
					tlConfirm.style.pointerEvents = "auto"
					clearInterval(tlTimerInterval)
					tlTimer.innerText = "0.0s"
				})
		}

		function updateTlTimer() {
			let elapsedTime = Date.now() - tlTimerStart
			document.getElementById("tlTimer").innerText = ((elapsedTime / 1000).toFixed(3)) + "s"
		}

		var overlayInfo = { x: 0, y: 0, w: 0, h: 0, opacity: 0.8, type: "" }
		overlayInput.onchange = function() {
			if (!overlayInput.files || !overlayInput.files[0]) return
			templateImage.src = URL.createObjectURL(overlayInput.files[0])
			templateImage.style.opacity = 0.8
		}
		async function generateOverlayUrl() {
			overlayInfo["type"] = overlayInput.files[0].type
			overlayInfo["data"] = btoa(String.fromCharCode(...new Uint8Array(await overlayInput.files[0].arrayBuffer())))
			return `${location.origin}/?server=${localStorage.server || DEFAULT_SERVER}&board=${localStorage.board || DEFAULT_BOARD}&overlay=${btoa(JSON.stringify(overlayInfo))}`
		}

		let blockedUsers = localStorage.blocked?.split(",") || []
		let targetedIntId = null
		let targetedMsgId = null
		let currentReply = null

		function openChatPanel() {
			chatPanel.setAttribute("open", "true")
			chatPanel.inert = false
		}

		function closeChatPanel() {
			messageInput.blur()
			chatPanel.removeAttribute("open")
			chatPanel.inert = true
		}
		closeChatPanel()

		function onChatContext(ev, senderId, msgId) {
			ev.preventDefault()

			if (chatContext.style.display == "block") {
				chatContext.style.display = "none"
			}
			else {
				let msgName = intIdNames.get(senderId)
				const identifier = msgName || ("#" + senderId)
				if (msgName) {
					if (msgName[msgName.length - 1] === "~") {
						msgName = msgName.slice(0, -1)
						userNote.style.display = "block"
						userNote.textContent = "This user is likely impersonating @" + msgName
					}
					else if (msgName[msgName.length - 1] === "‚úì") {
						msgName = msgName.slice(0, -1)
						userNote.style.display = "block"
						userNote.textContent = "This user is verified as @" + msgName
					}
					else {
						userNote.style.display = "none"
					}
				}

				targetedMsgId = msgId
				targetedIntId = senderId
				chatContext.style.display = "block"
				mentionUser.children[0].textContent = `${translate("mention")} ${identifier}`
				replyUser.children[0].textContent = `${translate("replyTo")} ${identifier}`
				blockUser.children[0].textContent =
					`${translate(blockedUsers.includes(senderId) ? "unblock" : "block")} ${identifier}`

				if (senderId == intId) {
					blockUser.style.pointerEvents = "none"
					blockUser.children[0].style.color = "grey"
					changeMyName.style.display = ""
				}
				else  {
					blockUser.style.pointerEvents = "all"
					blockUser.children[0].style.color = "black"
					changeMyName.style.display = "none"
				}

				chatContext.style.left = ev.pageX - chatPanel.offsetLeft + "px"
				chatContext.style.top = ev.pageY - chatPanel.offsetTop + "px"
			}
		}

		function redirectQueryLocation() {
			let redirectLocation = ({
				"?discord": "https://discord.com/invite/xbRrVSXJdZ",
				"?twitter": "https://twitter.com/rplacetk",
				"?reddit": "https://www.reddit.com/r/placetk",
				"?github": "https://github.com/rplacetk",
				"?telegram": "https://t.me/rplacelive",
				"?admin": "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
			})[location.search]
			if (redirectLocation) {
				location.replace(redirectLocation)
			}
		}
		redirectQueryLocation()

		async function blockWebviewLoad() {
			if (window.location !== window.parent.location || typeof window.Android !== "undefined" || typeof window.Kodular !== "undefined") {
				window.location.replace("fakeapp.html")
			}
		}
		blockWebviewLoad()

		// Prompt user if they want to install site as PWA if they press the modal button
		let pwaPrompter = null
		window.addEventListener("beforeinstallprompt", function(e) {
			e.preventDefault()
			pwaPrompter = e
		})
		window.addEventListener("contextmenu", function(e) {
			e.preventDefault()
		})

		// Cancel touchpad page zooming that interferes with canvas zooming
		if (!mobile) {
			function cancelZoomGesture(e) {
				e.preventDefault()
				document.body.style.zoom = 1
			}
			document.addEventListener("gesturestart", cancelZoomGesture)
			document.addEventListener("gesturechange", cancelZoomGesture)
			document.addEventListener("gestureend", cancelZoomGesture)
		}

		setTimeout(() => {
			if (window.connproblems) {
				connproblems.style.opacity = 1
			}
		}, 5000)

		if (localStorage.noad && Date.now() - localStorage.noad < 1.21e9) { // 14 days
			ad.style.display = "none"
		}
		else {
			let adI = Math.floor(Math.random() * ADS.length)
			function cycleAd() {
				const currentAd = ADS[adI % ADS.length]
				ad.style.setProperty("--adurl", `url(${currentAd.banners[lang] || currentAd.banners["en"]})`)
				ad.href = currentAd.url
				adI++
			}
			setInterval(cycleAd, 12e4) // 2 mins
			cycleAd()
		}
	</script>
</html>
