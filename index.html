<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<script>
		const CHAT_COLOURS = ["lightblue", "navy", "green", "purple", "grey", "brown", "orangered", "gold"]
		const VERIFIED_APP_HASH = "90e58b1f2c5fb98f74962806b85c2d7d3f7b18be8abe7a04f21e939868625357"
		const UNMUTED_SVG = '<path d="M10.543.5a1.12 1.12 0 00-1.182.117L3.789 4.875h-1.8A1.127 1.127 0 00.868 6v8a1.127 1.127 0 001.125 1.125h1.8l5.572 4.258a1.117 1.117 0 00.681.232 1.128 1.128 0 001.127-1.126V1.511A1.119 1.119 0 0010.543.5zm-.624 17.736l-5.708-4.361H2.118v-7.75h2.093l5.708-4.361zM13 3.375v1.25a5.375 5.375 0 010 10.75v1.25a6.625 6.625 0 000-13.25z"></path><path d="M16.125 10A3.129 3.129 0 0013 6.875v1.25a1.875 1.875 0 010 3.75v1.25A3.129 3.129 0 0016.125 10z"></path>'
		const MUTED_SVG = '<path d="M19.442 7.442l-.884-.884L16.5 8.616l-2.058-2.058-.884.884L15.616 9.5l-2.058 2.058.884.884 2.058-2.058 2.058 2.058.884-.884L17.384 9.5l2.058-2.058zM10.543.5a1.12 1.12 0 00-1.182.117L3.789 4.875h-1.8A1.127 1.127 0 00.868 6v8a1.127 1.127 0 001.125 1.125h1.8l5.572 4.258a1.117 1.117 0 00.681.232 1.128 1.128 0 001.127-1.126V1.511A1.119 1.119 0 0010.543.5zm-.624 17.736l-5.708-4.361H2.118v-7.75h2.093l5.708-4.361z"></path>'
		const DEFAULT_PALETTE_KEYS = "123456789abcdefghijklmnopqrstuvwxyz"

		const AUDIOS = {
			invalid: new Audio("./sounds/invalid.mp3"),
			highlight: new Audio("./sounds/highlight.mp3"),
			selectColour: new Audio("./sounds/select-colour.mp3"),
			closePalette: new Audio("./sounds/close-palette.mp3"),
			cooldownStart: new Audio("./sounds/cooldown-start.mp3"),
			cooldownEnd: new Audio("./sounds/cooldown-end.mp3"),
			bell: new Audio("./sounds/bell.mp3"),
			celebration: new Audio("./sounds/celebration.mp3")
		}

		const EMOJIS = new Map([
			[ "rofl", "ğŸ¤£" ],
			[ "joy", "ğŸ˜‚" ],
			[ "cool", "ğŸ˜" ],
			[ "sunglasses", "ğŸ˜" ],
			[ "heart", "â¤ï¸" ],
			[ "moyai", "ğŸ—¿" ],
			[ "bruh", "ğŸ—¿" ],
			[ "skull", "ğŸ’€" ],
			[ "sus", "à¶" ],
			[ "tr", "ğŸ‡¹ğŸ‡·" ],
			[ "turkey", "ğŸ‡¹ğŸ‡·" ],
			[ "ir", "ğŸ‡®ğŸ‡·" ],
			[ "iran", "ğŸ‡®ğŸ‡·" ],
			[ "uk", "ğŸ‡¬ğŸ‡§" ],
			[ "britain", "ğŸ‡¬ğŸ‡§" ],
			[ "usa", "ğŸ‡ºğŸ‡¸" ],
			[ "america", "ğŸ‡ºğŸ‡¸" ],
			[ "ru", "ğŸ‡·ğŸ‡º" ],
			[ "russia", "ğŸ‡·ğŸ‡º" ],
			[ "eyes", "ğŸ‘€" ],
			[ "fire", "ğŸ”¥" ],
			[ "thumbsup", "ğŸ‘" ],
			[ "thumbsdown", "ğŸ‘" ],
			[ "clown", "ğŸ¤¡" ],
			[ "facepalm", "ğŸ¤¦â€â™‚ï¸" ],
			[ "ok", "ğŸ‘Œ" ],
			[ "poop", "ğŸ’©" ],
			[ "rocket", "ğŸš€" ],
			[ "tada", "ğŸ‰" ],
			[ "celebration", "ğŸ‰" ],
			[ "moneybag", "ğŸ’°" ],
			[ "crown", "ğŸ‘‘" ],
			[ "muscle", "ğŸ’ª" ],
			[ "beer", "ğŸº" ],
			[ "pizza", "ğŸ•" ],
			[ "cookie", "ğŸª" ],
			[ "balloon", "ğŸˆ" ],
			[ "gift", "ğŸ"],
			[ "star", "â­ï¸" ],
			[ "love", "ğŸ˜" ],
			[ "crying", "ğŸ˜¢" ],
			[ "angry", "ğŸ˜ " ],
			[ "sleepy", "ğŸ˜´" ],
			[ "nerd", "ğŸ¤“" ],
			[ "laughing", "ğŸ˜†" ],
			[ "vomiting", "ğŸ¤®" ],
			[ "unicorn", "ğŸ¦„" ],
			[ "alien", "ğŸ‘½" ],
			[ "ghost", "ğŸ‘»" ],
			[ "skullcrossbones", "â˜ ï¸" ],
			[ "explosion", "ğŸ’¥" ],
			[ "shush", "ğŸ¤«" ],
			[ "deaf", "ğŸ§" ],
			[ "mew", "ğŸ¤«ğŸ§" ],
			[ "pray", "ğŸ™" ],
			[ "thinking", "ğŸ¤”" ],
			[ "sweat", "ğŸ˜…" ],
			[ "wave", "ğŸ‘‹"]
		])
		const CUSTOM_EMOJIS = new Map([
			[ "amogus", '<img src="custom_emojis/amogus.png" height="24">' ],
			[ "biaoqing", '<img src="custom_emojis/biaoqing.png" height="24">' ],
			[ "deepfriedh", '<img src="custom_emojis/deepfriedh.png" height="24">' ],
			[ "edp445", '<img src="custom_emojis/edp445.png" height="24">' ],
			[ "fan", '<img src="custom_emojis/fan.png" height="24">' ],
			[ "heavy", '<img src="custom_emojis/heavy.png" height="24">' ],
			[ "herkul", '<img src="custom_emojis/herkul.png" height="24">' ],
			[ "kaanozdil", '<img src="custom_emojis/kaanozdil.png" height="24">' ],
			[ "lowtiergod", '<img src="custom_emojis/lowtiergod.png" height="24">' ],
			[ "manly", '<img src="custom_emojis/manly.png" height="24">' ],
			[ "plsaddred", '<img src="custom_emojis/plsaddred.png" height="24">' ],
			[ "rplace", '<img src="custom_emojis/rplace.png" height="24">' ],
			[ "rplacediscord", '<img src="custom_emojis/rplacediscord.png" height="24">' ],
			[ "sonic", '<img src="custom_emojis/sonic.png" height="24">' ],
			[ "transparent", '<img src="custom_emojis/transparent.png" height="24">' ],
			[ "trollface", '<img src="custom_emojis/trollface.png" height="24">' ]
		])
		const COMMANDS = new Map([
			[ "help", "<kbd>Help information for live chat</kbd>" ],
			[ "name", "<kbd>Change your username</kbd>" ],
			[ "vip", "<kbd>Apply a VIP code</kbd>" ],
			[ "lookup", "<kbd>Get the IDs of all players with the given name</kbd>" ],
			[ "getid", "<kbd>View your own User Id, or provide a name to view a list of online player User Ids</kbd>" ],
			[ "whoplaced", "<kbd>View details of who placed the current pixel being hoveredd</kbd>" ]
		])

		// Flag emojis all sourced from openmoji.org, https://www.langoly.com/most-spoken-languages/
		const LANG_INFOS = new Map([
			["en", { name: "English", flag: "https://openmoji.org/data/color/svg/1F1EC-1F1E7.svg" }],
			["zh", { name: "ä¸­æ–‡", flag: "https://openmoji.org/data/color/svg/1F1E8-1F1F3.svg" }],
			["hi", { name: "à¤¹à¤¿à¤¨à¥à¤¦à¥€", flag: "https://openmoji.org/data/color/svg/1F1EE-1F1F3.svg" }],
			["es", { name: "EspaÃ±ol", flag: "https://openmoji.org/data/color/svg/1F1EA-1F1F8.svg" }],
			["fr", { name: "FranÃ§ais", flag: "https://openmoji.org/data/color/svg/1F1EB-1F1F7.svg" }],
			["ar", { name: "Ø¹Ø±Ø¨ÙŠ", flag: "https://openmoji.org/data/color/svg/1F1F8-1F1E6.svg", rtl: true }],
			["bn", { name: "à¦¬à¦¾à¦‚à¦²à¦¾", flag: "https://openmoji.org/data/color/svg/1F1EE-1F1F3.svg" }],
			["ru", { name: "pÑƒÑÑĞºĞ¸Ğ¹", flag: "https://openmoji.org/data/color/svg/1F1F7-1F1FA.svg" }],
			["pt", { name: "PortuguÃªs", flag: "https://openmoji.org/data/color/svg/1F1E7-1F1F7.svg" }],
			["ur", { name: "Ø§Ø±Ø¯Ùˆ", flag: "https://openmoji.org/data/color/svg/1F1F5-1F1F0.svg", rtl: true }],
			["de", { name: "Deutsch", flag: "https://openmoji.org/data/color/svg/1F1E9-1F1EA.svg" }],
			["jp", { name: "æ—¥æœ¬èª", flag: "https://openmoji.org/data/color/svg/1F1EF-1F1F5.svg" }],
			["tr", { name: "TÃ¼rkÃ§e", flag: "https://openmoji.org/data/color/svg/1F1F9-1F1F7.svg" }],
			["vi", { name: "Tiáº¿ng Viá»‡t", flag: "https://openmoji.org/data/color/svg/1F1FB-1F1F3.svg" }],
			["ko", { name: "í•œêµ­ì¸", flag: "https://openmoji.org/data/color/svg/1F1F0-1F1F7.svg" }],
			["it", { name: "Italiana", flag: "https://openmoji.org/data/color/svg/1F1EE-1F1F9.svg" }],
			["fa", { name: "ÙØ§Ø±Ø³ÛŒ", flag: "https://openmoji.org/data/color/svg/1F1EE-1F1F7.svg", rtl: true }],
			["sr", { name: "Ğ¡Ñ€Ğ¿ÑĞºĞ¸", flag: "https://openmoji.org/data/color/svg/1F1E6-1F1F1.svg"}],
			["az", { name: "AzÉ™rbaycan", flag: "https://openmoji.org/data/color/svg/1F1E6-1F1FF.svg", rtl: true }],
		])

		const DEFAULT_THEMES = new Map([
			[ "r/place 2022", { id: "r/place 2022", css: "rplace-2022.css", cssVersion: "14", pixelselect: "svg/pixel-select-2022.svg" }],
			[ "r/place 2023", { id: "r/place 2023", css: "rplace-2023.css", cssVersion: "14", pixelselect: "svg/pixel-select-2023.svg" }],
		])

		const ADS = [
			{ url: "https://youtu.be/R3UBtMloTdI", banners: { en: "images/august21-ad.png" } },
			{ url: "https://t.me/rplacelive", banners: { en: "images/telegram-ad.png" } },
			{ url: "https://discord.gg/4XnZ9WGux2", banners: { en: "images/discord-ad.png" } },
			{ url: "https://arbitrum.life", banners: { en: "https://avatars.githubusercontent.com/u/131141781" } },
		]

		const PUNISHMENT_STATE = {
			mute: 0,
			ban: 1,
			appealRejected: 2,
		}

		const MAX_CHANNEL_MESSAGES = 100
	</script>
	<script>
		if(!("subtle" in (window.crypto || {}))) location.protocol = "https:"
		const automated = navigator.webdriver
		// csrfstate not used at the moment, may be later to encode some extra info for client
		let params = new URLSearchParams(location.search)
		let csrfState = params.get("state"),
			redditOauthCode = params.get("code")
			boardParam = params.get("board"),
			serverParam = params.get("server")

		if (boardParam && serverParam) {
			if (localStorage.server != serverParam || localStorage.board != boardParam) {
				localStorage.server = serverParam
				localStorage.board = boardParam
				history.pushState(null, '', location.origin)
				window.location.reload()
			}
		}

		// Register PWA Service worker
		if ("serviceWorker" in navigator) {
			navigator.serviceWorker.register("./sw.js?v=2.0")
		}
		const intIdPositions = new Map() // position : intId
		const intIdNames = new Map() // intId : name
		let account = null
		let intId = null
		let chatName = null
		let fetchLinkKey = null // function injected by wscapsule
		let setName = null // function injected by wscapsule
		let requestPixelPlacers = null // function injected by wscapsule
		let requestLoadChannelPrevious = null // function injected by wscapsule
		let chatReport = null // function injected by wscapsule
		let chatReact = null // function injected by wscapsule
		let canvasLocked = false // Server will tell us this
		let includesPlacer = false // Server will tell us this

		const wscapsule = ((send, addEventListener, call) => {
			let focused = true
			call(addEventListener, window, "blur", () => focused = false)
			call(addEventListener, window, "focus", () => focused = true)

			let svUri = localStorage.server || DEFAULT_SERVER
			if (localStorage.vip) {
				if (!svUri.endsWith("/")) svUri += "/"
				svUri += localStorage.vip
			}
			let ws = new WebSocket(svUri)
			delete WebSocket

			function _chatReport(messageId, senderId) {
				const reason = prompt("Enter the reason for why you are reporting this message (max 280 chars)\n\n" +
					`Additional info:\nMessage ID: ${messageId}\nSender ID: ${senderId}\n`)
				if (!reason || !reason.trim()) {
					return
				}
				const reportBuffer = encoder.encode("XXXXX" + reason)
				reportBuffer[0] = 14
				reportBuffer[1] = messageId >> 24
				reportBuffer[2] = messageId >> 16
				reportBuffer[3] = messageId >> 8
				reportBuffer[4] = messageId & 255
				call(send, ws, reportBuffer)
				alert("Report sent!\nIn the meantime you can block this user by 'right clicking / press hold on the message' > 'block'")
			}
			chatReport = _chatReport

			function _chatReact(messageId, reactKey) {
				const reactBuffer = encoder.encode("XXXXX" + reactKey)
				reactBuffer[0] = 18
				reactBuffer[1] = messageId >> 24
				reactBuffer[2] = messageId >> 16
				reactBuffer[3] = messageId >> 8
				reactBuffer[4] = messageId & 255
				call(send, ws, reactBuffer)
			}
			chatReact = _chatReact

			function createLiveChatMessage(messageId, txt, senderId, name, sendDate, repliesTo = null, reactions = null) {
				const message = document.createElement("r-live-chat-message")
				message.messageId = messageId
				message.content = txt
				message.senderId = senderId
				message.name = name
				message.sendDate = sendDate
				message.repliesTo = repliesTo
				message.reactions = reactions
				return message
			}

			ws.onopen = function(e) {
				initialConnect = true
				if (automated) {
					console.error("Unsupported environment. Connection can not be guarenteed")
					function reportUsage() {
						const activityBuffer = encoder.encode(`\x1eWindow outer width: ${window.outerWidth}\nWindow inner width: ${window.innerWidth}\n` +
							`Window outer height: ${window.outerHeight}\nWindow inner height: ${window.innerHeight}\nLast mouse move: ${new Date(lastMouseMove).toISOString()}\n` +
							`Mouse X (mx): ${mx}\nMouse Y (my): ${my}\nLocal storage: ${JSON.stringify(localStorage, null, 4)}`)
						call(send, ws, activityBuffer)
					}
					setInterval(reportUsage, 3e5) // 5 mins
					reportUsage()
				}
			}
			ws.onmessage = async function({data}) {
				delete sessionStorage.err
				data = new DataView(await data.arrayBuffer())

				switch (data.getUint8(0)) {
				case 0: {
					let pi = 1
					const paletteLength = data.getUint8(pi++)
					PALETTE = [...new Uint32Array(data.buffer.slice(pi, pi += paletteLength * 4))]
					PALETTE_USABLE_REGION.start = data.getUint8(pi++)
					PALETTE_USABLE_REGION.end = data.getUint8(pi++)
					generatePalette()
					const binds = (localStorage.paletteKeys || DEFAULT_PALETTE_KEYS)
					generateIndicators(binds)
					// Board might have already been drawn with old palette so we need to draw it again
					if (boardAlreadyRendered === true) {
						renderAll()
					}
					break
				}
				case 1: {
					CD = data.getUint32(1) * 1000 // Current cooldown
					COOLDOWN = data.getUint32(5)

					// New server packs canvas width and height in code 1, making it 17
					if (data.byteLength == 17) {
						let width = data.getUint32(9)
						let height = data.getUint32(13)
						setSize(width, height)
						runLengthDecodeBoard(await preloadedBoard, width * height)
						hideLoadingScreen()
					}
					break
				}
				case 2: {
					// Old server "changes" packet - preloadedBoard = http board, data = changes
					runLengthChanges(data, await preloadedBoard)
					hideLoadingScreen()
					break
				}
				case 3: { // Online
					online = data.getUint16(1)
					onlineCounter.textContent = online
					sendPostsFrameMessage("onlineCounter", online)
					break
				}
				case 5: { // Pixel with included placer
					let i = 1
					while (i < data.byteLength) {
						let position = data.getUint32(i); i += 4
						seti(position, data.getUint8(i)); i += 1
						intIdPositions.set(position, data.getUint32(i)); i += 4
					}
					break
				}
				case 6: { // Pixel without included placer
					let i = 0
					while (i < data.byteLength - 2) {
						seti(data.getUint32(i += 1), data.getUint8(i += 4))
					}
					break
				}
				case 7: { // Rejected pixel
					CD = data.getUint32(1) * 1000
					seti(data.getUint32(5), data.getUint8(9))
					break
				}
				case 8: { // Canvas restriction
					canvasLocked = !!data.getUint8(1)
					canvasLock.style.display = canvasLocked ? "flex" : "none"
					const reason = decoder.decode(data.buffer.slice(2))
					if (reason) { // TODO: Find a more elegant solution
						alert(reason)
					}
					break
				}
				case 9: { // Placer info region
					let i = data.getUint32(1)
					const regionWidth = data.getUint8(5)
					const regionHeight = data.getUint8(6)

					let dataI = 7
					while (dataI < data.byteLength) {
						for (let xi = i; xi < i + regionWidth; xi++) {
							const placerIntId = data.getUint32(dataI)
							if (placerIntId !== 0xFFFFFFFF) {
								intIdPositions.set(xi, placerIntId)
							}
							dataI += 4
						}
						i += WIDTH
					}
					break
				}
				case 11: { // Player int ID // TODO: Integrate into packet 1
					intId = data.getUint32(1)
					break
				}
				case 12: { // Name info
					for (let i = 1; i < data.byteLength;) {
						let pIntId = data.getUint32(i); i += 4
						let pNameLen = data.getUint8(i); i++
						let pName = decoder.decode(data.buffer.slice(i, (i += pNameLen)))

						intIdNames.set(pIntId, pName)
						// Occurs either if server has sent us name it has remembered from a previous session,
						// or we have just sent server packet 12 name update, and it is sending us back our name
						if (pIntId == intId) {
							chatName = pName
							namePanel.style.visibility = "hidden"
						}
					}
					break
				}
				case 13: { // Live chat history
					let i = 1
					let fromMessageId = data.getUint32(i); i += 4
					let count = data.getUint8(i) & 127
					let before = data.getUint8(i) >> 7; i++
					let channelLen = data.getUint8(i++)
					let channel = decoder.decode(data.buffer.slice(i, (i += channelLen)))

					let newChatScroll = chatMessages.scrollTop
					const messageRenderPromises = []

					if (channel !== currentChannel) {
						return
					}
					while (i < data.byteLength) {
						let offset = i
						const messageLength = data.getUint16(offset); offset += 2
						const messageId = data.getUint32(offset); offset += 4
						const txtLength = data.getUint16(offset); offset += 2
						let txt = decoder.decode(data.buffer.slice(offset, (offset += txtLength)))
						const intId = data.getUint32(offset); offset += 4 // sender int ID
						const name = intIdNames.get(intId)

						const sendDate = data.getUint32(offset); offset += 4
						const reactions = new Map()
						const reactionsL = data.getUint8(offset); offset++
						for (let j = 0; j < reactionsL; j++) {
							const reactionKeyL = data.getUint8(offset); offset++
							const reactionKey = decoder.decode(data.buffer.slice(i, (i += reactionKeyL)))
							const reactors = new Set()
							const reactorsL = data.getUint32(offset); offset += 4
							for (let k = 0; k < reactorsL; k++) {
								const reactor = data.getUint32BE(offset); offset += 4
								reactors.add(reactor)
							}
							reactions.set(reactionKey, reactors)
						}
						const channelL = data.getUint8(offset); offset++
						const channel = decoder.decode(data.buffer.slice(offset, (offset += channelL)))
						let repliesTo = null
						if (messageLength - (offset - i) == 4) {
							repliesTo = data.getUint32(offset); offset += 4
						}

						// TODO: We will worry about after when we get dynamic message loading
						const newMessage = createLiveChatMessage(messageId, txt, intId, name, sendDate, repliesTo, reactions)
						if (before) {
							chatMessages.prepend(newMessage)
							const channelMessages = cMessages.get(currentChannel)
							channelMessages.unshift(newMessage)
						}
						messageRenderPromises.push(
							newMessage.updateComplete.then(() => {
								newChatScroll += newMessage.offsetHeight
							})
						)
						i = offset
					}
					Promise.all(messageRenderPromises).then(() => {
						// Looks more seamless if the last of the loaded previous messages can be seen
						// in place of the previous button
						chatMessages.scrollTop = newChatScroll - chatPreviousButton.offsetHeight
						// Prevent site from spam loading chat messages when already at scroll top until it
						// received the last lot
						chatPreviousLoadDebounce = false
					})
					break
				}
				case 14: { // Moderation
					let i = 1
					const state = data.getUint8(i++)
					const startDate = data.getUint32(i) * 1000; i += 4
					const endDate = data.getUint32(i) * 1000; i += 4
					const reasonLen = data.getUint8(i++)
					const reason = decoder.decode(data.buffer.slice(i, i + reasonLen)); i += reasonLen
					const appealLen = data.getUint8(i++)
					const appeal = decoder.decode(data.buffer.slice(i, i + appealLen)); i += appealLen
					// TODO: Localise
					if (state === PUNISHMENT_STATE.mute) {
						messageInput.disabled = true
						punishmentNote.innerHTML = "You have been <stronng>muted</stronng>, you can not send messages in live chat."
					}
					else if (state === PUNISHMENT_STATE.ban) {
						messageInput.disabled = true
						canvasLock.style.display = "flex"
						canvasLocked = true
						punishmentNote.innerHTML = "You have been <strong>banned</strong> from placing on the canvas or sending messages in live chat."
					}
					punishmentUserId.textContent = `Your User ID: #${intId}`
					punishmentStartDate.textContent = `Started on: ${new Date(startDate).toLocaleString()}`
					punishmentEndDate.textContent = `Ending on: ${new Date(endDate).toLocaleString()}`
					punishmentReason.textContent = `Reason: ${reason}`
					punishmentAppeal.textContent = `Appeal status: ${(appeal && appeal !== "null") ? appeal : 'Unappealable'}`
					punishmentMenu.setAttribute("opened", "true")
					break
				}
				case 15: { // Chat
					let repliesTo = null

					let offset = 1
					const msgType = data.getUint8(offset); offset++
					const messageId = data.getUint32(offset); offset += 4
					const txtLength = data.getUint16(offset); offset += 2
					let txt = decoder.decode(data.buffer.slice(offset, (offset += txtLength)))
					const senderIntId = data.getUint32(offset); offset += 4 // sender int ID
					const name = intIdNames.get(senderIntId)

					if (msgType == 0) { // live
						const sendDate = data.getUint32(offset); offset += 4
						const reactions = new Map()
						const reactionsL = data.getUint8(offset); offset++
						for (let j = 0; j < reactionsL; j++) {
							const reactionKeyL = data.getUint8(offset); offset++
							const reactionKey = decoder.decode(data.buffer.slice(i, (i += reactionKeyL)))
							const reactors = new Set()
							const reactorsL = data.getUint32(offset); offset += 4
							for (let k = 0; k < reactorsL; k++) {
								const reactor = data.getUint32BE(offset); offset += 4
								reactors.add(reactor)
							}
							reactions.set(reactionKey, reactors)
						}
						const channelL = data.getUint8(offset); offset++
						const channel = decoder.decode(data.buffer.slice(offset, (offset += channelL)))
						if (data.byteLength - offset >= 4) {
							repliesTo = data.getUint32(offset)
						}
						if (!cMessages.has(channel)) {
							break
						}

						const newMessage = createLiveChatMessage(messageId, txt, senderIntId, name, sendDate, repliesTo, reactions)
						if (senderIntId !== 0 && blockedUsers.includes(senderIntId)) {
							newMessage.style.color = "transparent"
							newMessage.style.textShadow = "0px 0px 6px black"
						}
						if (txt.includes("@" + chatName) || txt.includes("@#" + intId) || txt.includes("@everyone")) {
							newMessage.setAttribute("mention", "true")
							if (currentChannel == channel) AUDIOS.closePalette.run()
						}
						const atScrollBottom = chatMessages.scrollTop + chatMessages.offsetHeight + 64 >= chatMessages.scrollHeight

						// Insert the message into the channel
						const channelMessages = cMessages.get(channel)
						channelMessages.push(newMessage)
						if (channelMessages.length > MAX_CHANNEL_MESSAGES) {
							channelMessages.shift()
						}
						if (channel == currentChannel) {
							if (chatMessages.children.length > MAX_CHANNEL_MESSAGES) {
								chatMessages.children[0].remove()
							}
							chatMessages.insertAdjacentElement("beforeEnd", newMessage)
							newMessage.updateComplete.then(() => {
								// If at scroll bottom (we scroll down when new chat messages come)
								if (atScrollBottom) {
									chatMessages.scrollTo(0, chatMessages.scrollHeight)
								}
							})
						}
					}
					else { // place
						if (!placeChat) return
						let msgPos = data.getUint32(offset)
						txt = txt.substring(0, 56)

						const placeMessage = document.createElement("placechat")
						placeMessage.innerHTML = `<span title="${(new Date()).toLocaleString()}" style="color: ${CHAT_COLOURS[hash("" + senderIntId) & 7]};">[${name}]</span><span>${txt}</span>`
						placeMessage.style.left = (msgPos % WIDTH) + "px"
						placeMessage.style.top = (Math.floor(msgPos / WIDTH) + 0.5) + "px"
						canvparent2.appendChild(placeMessage)

						//Remove message after given time.
						setTimeout(() => {
							canvparent2.removeChild(placeMessage)
						}, localStorage.placeChatTime || 7e3)
					}
					break
				}
				case 16: { // Captcha success
					captchaPopup.style.display = "none"
					break
				}
				case 17: {// Live chat delete
					const messageId = data.getUint32(1)
					for (const channel of cMessages.values()) {
						for (const messageEl of channel) {
							if (messageEl.messageId !== messageId) continue
							channel.splice(channel.indexOf(messageEl), 1)
							messageEl.remove()
						}
					}
					break
				}
				case 18: { // Live chat reaction
					const messageId = data.getUint32(1)
					const reactorId = data.getUint32(5)
					const reactionKey = decoder.decode(data.buffer.slice(9))
					for (const channel of cMessages.values()) {
						for (const messageEl of channel) {
							if (messageEl.messageId !== messageId) {
								continue
							}

							const currentReactions = messageEl.reactions
							const reactors = currentReactions?.get(reactionKey) || new Set()
							if (!reactors.has(reactorId)) {
								const newReactions = currentReactions ? new Map(currentReactions) : new Map()
								reactors.add(reactorId)
								newReactions.set(reactionKey, reactors)
								messageEl.reactions = newReactions
							}
						}
					}
					break
				}
				case 20: { // Text capcha
					let textsSize = data.getUint8(1)
					let texts = decoder.decode(new Uint8Array(data.buffer).slice(2, textsSize + 2)).split("\n")
					let imageData = new Uint8Array(data.buffer).slice(2 + textsSize)
					captchaOptions.innerHTML = ""

					for (let text of texts) {
						let button = document.createElement("button")
						button.textContent = text
						captchaOptions.appendChild(button)

						button.addEventListener("click", (event) => {
							call(send, ws, encoder.encode("\x10" + event.target.textContent))
							captchaOptions.style.pointerEvents = "none"
						})
					}
					captchaPopup.style.display = "flex"
					captchaOptions.style.pointerEvents = "all"
					const imageBlob = new Blob([imageData], { type: "image/png" })
					if (webGLSupported) {
						updateImgCaptchaCanvas(imageBlob)
					}
					else {
						updateImgCaptchaCanvasFallback(imageBlob)
					}
					break
				}
				case 21: { // Math captcha
					console.error("Math captcha not yet supported. Ignoring.")
					break
				}
				case 22: { // Emoji captcha
					let emojisSize = data.getUint8(1)
					let emojis = decoder.decode(new Uint8Array(data.buffer).slice(2, emojisSize + 2)).split("\n")
					let imageData = new Uint8Array(data.buffer).slice(2 + emojisSize)
					captchaOptions.innerHTML = ""

					let captchaSubmitted = false
					for (let emoji of emojis) {
						let buttonParent = document.createElement("button")
						buttonParent.classList.add("captcha-options-button")
						buttonParent.setAttribute("value", emoji)
						let emojiImg = document.createElement("img")
						emojiImg.src = `./tweemoji/${emoji.codePointAt(0).toString(16)}.png`
						emojiImg.alt = emoji
						emojiImg.title = emoji
						emojiImg.fetchPriority = "high"
						emojiImg.addEventListener("load", (event) => {
							buttonParent.classList.add("loaded")
						})
						buttonParent.appendChild(emojiImg)
						captchaOptions.appendChild(buttonParent)

						function submitCaptcha(event) {
							if (captchaSubmitted || !emoji) {
								return console.error("Could not send captcha response. No emoji?")
							}
							captchaSubmitted = true
							call(send, ws, encoder.encode("\x10" + emoji))
							captchaOptions.style.pointerEvents = "none"
							clearCaptchaCanvas()
						}
						buttonParent.addEventListener("click", submitCaptcha)
						emojiImg.addEventListener("click", submitCaptcha)
						buttonParent.addEventListener("touchend", submitCaptcha)
						emojiImg.addEventListener("touchend", submitCaptcha)
					}

					captchaPopup.style.display = "flex"
					captchaOptions.style.pointerEvents = "all"
					const imageBlob = new Blob([imageData], { type: "image/png" })
					if (webGLSupported) {
						updateImgCaptchaCanvas(imageBlob)
					}
					else {
						updateImgCaptchaCanvasFallback(imageBlob)
					}
					break
				}
				case 23: {
					let a=data.getUint32(1),b=5+a,c=data.buffer.slice(5,5+a),f=new Uint8Array(9),u=new DataView(f.buffer)
					;window.challengeData=new Uint8Array(data.buffer.slice(b));let d=await Object.getPrototypeOf(async function(){}).constructor(atob(decoder.decode(c)))()
					;delete window.challengeData;u.setUint8(0,23);u.setBigInt64(1,d);call(send,ws,u.buffer);
					break
				}
				case 24: { // Turnstile
					const siteKey = decoder.decode(data.buffer.slice(1))
					const siteVariant = document.documentElement.dataset.variant
					const turnstileTheme = siteVariant === "dark" ? "dark" : "light"

					turnstileMenu.setAttribute("opened", true)
					turnstile.ready(function () {
						turnstile.render("#turnstileContainer", {
							sitekey: siteKey,
							theme: turnstileTheme,
							language: lang,
							callback: function(token) {
								call(send, ws, encoder.encode("\x18" + token))
							},
						})
					})
					break
				}
				case 25: { // Turnstile success
					turnstileMenu.removeAttribute("opened")
					break
				}
				case 110: {
					const requestsLength = linkKeyRequests.length
					if (!requestsLength) {
						console.error("Could not resolve link key, no existing link key requests could be found")
						break
					}
					const instanceId = data.getUint32(1)
					const linkKey = decoder.decode(data.buffer.slice(5))
					linkKeyRequests[requestsLength - 1].resolve({ linkKey, instanceId })
					break
				}
				}
			}
			ws.onclose = async function(e) {
				console.error(e)
				CD = null
				if (e.code == 1006 && !sessionStorage.err) {
					sessionStorage.err = "1"
					window.location.reload(true)
				}
				loadingScreen.children[0].src = "images/rplace-offline.png"
				showLoadingScreen()
				loadingMessage.hidden = false
				loadingMessage.textContent = `${await translate("disconnectedFromServer")}: ${e.reason}`
			}

			let linkKeyRequests = []
			async function _fetchLinkKey() {
				linkKeyRequest = new PublicPromise()
				linkKeyRequests.push(linkKeyRequest)
				call(send, ws, new Uint8Array([110]))
				const linkInfo = await linkKeyRequest.promise
				return linkInfo
			}
			fetchLinkKey = _fetchLinkKey
			window["fetchLinkKey"] = _fetchLinkKey

			function _setName(uname) {
				if (uname.length > 16) return
				uname ||= "anon"

				const nameBuf = encoder.encode("\x0C" + uname)
				call(send, ws, nameBuf)
			}
			setName = _setName

			// Requests all the pixel placers for a given region from the server to be loaded into
			function _requestPixelPlacers(x, y, width, height) {
				if (ws.readyState !== ws.OPEN) {
					return
				}
				const placerInfoBuf = new DataView(new Uint8Array(7).buffer)
				placerInfoBuf.setUint8(0, 9)
				placerInfoBuf.setUint32(1, x + y * WIDTH)
				placerInfoBuf.setUint8(5, width)
				placerInfoBuf.setUint8(6, height)
				call(send, ws, placerInfoBuf)
			}
			requestPixelPlacers = _requestPixelPlacers

			function put() {
				// If CD is null but we have already made that initial connection, we have likely ghost disconnected from the WS
				if (!focused || !initialConnect || (CD === null && initialConnect) || CD > Date.now()) {
					return
				}

				pok.classList.remove("enabled")
				set(Math.floor(x), Math.floor(y), PEN)
				canvselect.style.background = ""
				canvselect.children[0].style.display = "block"
				canvselect.style.outline = ""
				canvselect.style.boxShadow = ""
				palette.style.transform = "translateY(100%)"
				AUDIOS.cooldownStart.run()
				CD = Date.now() + (localStorage.vip ? (localStorage.vip[0] == '!' ? 0 : COOLDOWN / 2) : COOLDOWN)

				const pixelView = new DataView(new Uint8Array(6).buffer)
				pixelView.setUint8(0, 4)
				pixelView.setUint32(1, Math.floor(x) + Math.floor(y) * WIDTH)
				pixelView.setUint8(5, PEN)

				if (!mobile) {
					colours.children[PEN].classList.remove("sel")
					PEN = -1
				}

				localStorage.placed = (localStorage.placed >>> 0) + 1
				call(send, ws, pixelView)
			}
			let pok = document.getElementById("pok")

			function onOkClicked(e) {
				if (!e.isTrusted) return
				if (pok.classList.contains("enabled")) put()
				hideIndicators()
			}
			call(addEventListener, pok, "click", onOkClicked)

			function sendLiveChatMsg(message) {
				if (message.startsWith(":name")) {
					namePanel.style.visibility = "visible"
					nameInput.value = message.slice(5).trim()
					return
				}
				else if (message.startsWith(":vip")) {
					let key = message.slice(4).trim()
					localStorage.vip = key
					window.location.reload(true)
					return
				}
				else if (localStorage.vip && message.includes(localStorage.vip)) {
					alert("Can't send VIP key in chat. Use ':vip yourvipkeyhere' to apply a VIP key")
					return
				}
				else if (message.startsWith(":getid")) {
					let targetName = message.slice(6).trim().toLowerCase()
					if (!targetName) {
						alert("Your User ID is: #" + intId)
					}
					else {
						let foundUsers = `Found Users with name '${targetName}:'\n`
						for (let pair of intIdNames) {
							if (pair[1] === targetName) {
								foundUsers += `${pair[1]}, #${pair[0]}\n`
							}
						}

						alert(foundUsers)
					}
					return
				}
				else if (message.startsWith(":whoplaced")) {
					let id = intIdPositions.get(Math.floor(x) + Math.floor(y) * WIDTH)
					if (id === undefined) {
						alert("Could not find details of who placed pixel at current location...")
						return
					}
					let name = intIdNames.get(id)
					alert(`Details of who placed at ${Math.floor(x)}, ${Math.floor(y)
						}:\nName: ${name || 'anon'
						}\nUser ID: #${id}`)
					return
				}
				else if (message.startsWith(":help")) {
					const newMessage = createLiveChatMessage(0, `
# Chat styling:
---
Text in rplace live chat can be styled using a simplified version of markdown, currently:
**bold**, *italic*, ||hidden||, __underline__, and ~strikethrough~ text are supported.

### Headers:
Use # for a large header, ## for medium, and ### for small. Donâ€™t forget to add a space between the leading heading character and your text!

### Separators:
To create a separator, create a blank line (Shift + Enter on keyboard) and insert a triple dash ---.


# Chat commands:
---
:vip, :name, :lookup, :getid, :whoplaced

## Usage:
:command arg1 arg2 arg3

## Example:
:name zekiah
(^ Will set your username to 'zekiah')`, 0, ":HELP@RPLACE.LIVE", Date.now())
					chatMessages.insertAdjacentElement("beforeEnd", newMessage)
					return
				}

				const encodedChannel = encoder.encode(currentChannel)
				const encodedMsg = encoder.encode(message)

				let msgArray = new Uint8Array(1 + 1 + 2 + encodedMsg.byteLength + 1
					+ encodedChannel.byteLength + (currentReply ? 4 : 0))
				let msgView = new DataView(msgArray.buffer)

				let offset = 0;
				msgView.setUint8(offset++, 15)
				msgView.setUint8(offset++, 0) // type
				msgView.setUint16(offset, encodedMsg.byteLength) // msg length
				offset += 2
				msgArray.set(encodedMsg, offset)
				offset += encodedMsg.byteLength
				msgView.setUint8(offset, encodedChannel.byteLength)
				offset += 1
				msgArray.set(encodedChannel, offset)
				offset += encodedChannel.byteLength
				if (currentReply != null) {
					msgView.setUint32(offset, currentReply)
				}

				chatCancelReplies()
				call(send, ws, msgView)
			}

			function sendPlaceMsg(message) { // message put on the canvas
				const encodedMsg = encoder.encode(message)

				let msgArray = new Uint8Array(1 + 1 + 2 + encodedMsg.byteLength + 4)
				let msgView = new DataView(msgArray.buffer)
				let offset = 0
				msgView.setUint8(offset++, 15)
				msgView.setUint8(offset++, 1) // type
				msgView.setUint16(offset, encodedMsg.byteLength)
				offset += 2
				msgArray.set(encodedMsg, offset)
				offset += encodedMsg.byteLength
				msgView.setUint32(offset, Math.floor(y) * WIDTH + Math.floor(x))

				call(send, ws, msgView)
			}

			messageTypePanel.children[0].onclick = e => {
				sendPlaceMsg(messageInput.value)
				messageInput.value = ""
			}

			messageTypePanel.children[1].onclick = e => {
				sendLiveChatMsg(messageInput.value)
				messageInput.value = ""
			}

			messageInput.onkeydown = e => {
				if (!e.isTrusted) return
				if (e.key == "Enter" && !e.shiftKey) {
					// ctrl + enter send as place chat, enter send as normal live chat
					if (e.ctrlKey) sendPlaceMsg(messageInput.value)
					else sendLiveChatMsg(messageInput.value)
					e.preventDefault()
					messageInput.value = ""
					updateMessageInputHeight()
				}
			}

			call(addEventListener, document.body, "keydown", function(e) {
				if (!e.isTrusted) return

				// Handle keybindings
				if (!("value" in document.activeElement)) {
					//"Shift+O" to open overlay menu
					if (e.key === "O" && e.shiftKey) {
						e.preventDefault()
						overlayMenu.toggleAttribute("opened")
					}
					else if (e.key === "/") {
						e.preventDefault()
						openChatPanel()
						messageInput.focus()
					}
					else if (e.key === "Escape") {
						// TODO: Not optimal, but it works for now
						e.preventDefault()
						modal.showModal()
					}
					else if ((e.key === "=" || e.key == "+")) {
						e.preventDefault()
						z += 0.02
						pos()
					}
					else if (e.key === "-") {
						e.preventDefault()
						z -= 0.02
						pos()
					}

					// Move around with arrow keys
					let moveEaseI = 10
					let repeatFunc = setInterval(function() {
						// We use 55 because: 10/55+9/55+8/55+7/55+6/55+5/55+4/55+3/55+2/55+1/55 = 1
						switch (e.keyCode) {
						case 37:
							x -= moveEaseI / 55
							arrowkeyDown.right = true
							break //right
						case 38:
							y -= moveEaseI / 55
							arrowkeyDown.up = true
							break //up
						case 39:
							x += moveEaseI / 55
							arrowkeyDown.left = true
							break //left
						case 40:
							y += moveEaseI / 55
							arrowkeyDown.down = true
							break //down
						}
						pos()
						moveEaseI--
						if (moveEaseI <= 0) clearInterval(repeatFunc)
					}, 16)
				}

				//Begin palette commands
				if (onCooldown || canvasLocked) return
				//"Enter" key to place selected block without using mouse
				if (e.keyCode == 13 && !("value" in document.activeElement)) call(onOkClicked, pok, e)
				//Keyboard shortcuts for selecting palette colours
				let keyIndex = null
				if (document.activeElement != document.body)return
				keyIndex = (localStorage.paletteKeys || DEFAULT_PALETTE_KEYS).indexOf(e.key)
				if (keyIndex == -1) return
				if (palette.style.transform == "translateY(100%)")
					showPalette()
				for (let c = 0; c < document.getElementById("colours").children.length; c++) {
					document.getElementById("colours").children[c].firstChild.style.visibility = "visible"
				}
				let colourI = [...(document.getElementById("colours").children)]
					.indexOf(document.getElementById("colours").children[keyIndex])
				if (colourI < 0) return
				let el = document.getElementById("colours").children[PEN]
				if (el) {
					el.classList.remove("sel")
				}
				PEN = keyIndex;
				AUDIOS.selectColour.run()
				canvselect.style.background = document.getElementById("colours").children[keyIndex].style.background
				document.getElementById("colours").children[keyIndex].classList.add("sel")
				pok.classList.add("enabled")
				canvselect.children[0].style.display = "none"
				canvselect.style.outline= "8px white solid"
				canvselect.style.boxShadow= "0px 2px 4px 0px rgb(0 0 0 / 50%)"
			})

			call(addEventListener, maincontent, "touchend", function(e) {
				if (!e.isTrusted) return

				for (let t of e.changedTouches) {
					assign2: if (touch2 && touch2.identifier == t.identifier) touch2 = null
					else if (touch1 && touch1.identifier == t.identifier) {
						[touch1, touch2] = [touch2, null]
						if (touchmoved > 0 && canvparent2.contains(e.target)){
							if (e.target != maincontent && !canvparent2.contains(e.target))
								break assign2
							clicked(t.clientX, t.clientY)
						}
					}
					if ("value" in e.target) e.target.focus()
					let target = e.target
					while (!target.dispatchEvent) {
						target = target.parentElement
					}
					if (target == pok) {
						call(onOkClicked, pok, e)
					}
					else {
						if (touchmoved > 0)
							target.dispatchEvent(new MouseEvent('click', { bubbles:true } ))
					}
				}
			})
			function _requestLoadChannelPrevious(msgCount=64) {
				chatPreviousLoadDebounce = true
				const encChannel = encoder.encode(currentChannel)
				let view = new DataView(new Uint8Array(6 + encChannel.byteLength).buffer)
				view.setUint8(0, 13)
				view.setUint32(1, chatMessages.children[0]?.messageId || 0)
				view.setUint8(5, msgCount|128) // 128 = before (most significant bit)
				for (let i = 0; i < encChannel.byteLength; i++) {
					view.setUint8(6 + i, encChannel[i])
				}
				call(send, ws, view.buffer)
			}
			requestLoadChannelPrevious = _requestLoadChannelPrevious
			call(addEventListener, chatMessages, "scroll", () => {
				if (chatMessages.scrollTop < 4) {
					if (chatPreviousAutoLoad === true && chatPreviousLoadDebounce === false) {
						_requestLoadChannelPrevious()
					}
					else {
						chatPreviousButton.dataset.hidden = "false"
					}
				}
				else {
					chatPreviousButton.dataset.hidden = "true"
				}
			})
			call(addEventListener, chatPreviousButton, "click", () => {
				_requestLoadChannelPrevious()
				// Keep loading previous for this channel as they scroll up
				chatPreviousAutoLoad = true
			})
			call(addEventListener, modOptionsButton, "click", function() {
				const reason = modReason.value.slice(0, 300)
				const encReason = encoder.encode(reason)
				// 0 - kick, 1 - mute, 2 - ban, 3 - captcha, 4 - delete
				let action = null
				let view = null
				let offset = 2
				let statusMsg = ""

				function setModView(extraLength) {
					view = new DataView(new Uint8Array(2 + extraLength + encReason.byteLength).buffer)
					view.setUint8(0, 98)
				}
				function setModReason(offset) {
					for (let ri = 0; ri < encReason.byteLength; ri++) {
						view.setUint8(offset + ri, encReason[ri])
					}
				}
				if (modActionKick.checked) {
					setModView(4)
					view.setUint8(1, 0)
					view.setUint32(2, modMemberId.value)
					setModReason(6)
					statusMsg = `Kicked player ${modMemberId.value} with reason '${reason}'`
				}
				else if (modActionMute.checked || modActionBan.checked) {
					const action = modActionMute.checked ? 1 : 2
					const seconds = (+modDurationS.value||0)
					const minutes = (+modDurationM.value||0)
					const hours = (+modDurationH.value||0)
					setModView(8)
					view.setUint8(1, action)
					view.setUint32(2, modMemberId.value)
					view.setUint32(6, seconds + minutes * 60 + hours * 3600)
					setModReason(10)
					statusMsg = `${["Kicked","Banned"][action-1]} player ${modMemberId.value} for ${hours
						} hours, ${minutes} minutes, and ${seconds} seconds with reason '${reason}'`
				}
				else if (modActionCaptcha.checked) {
					setModView(4)
					view.setUint8(1, 3)
					view.setUint32(2, modAffectsAll.checked ? 0 : modMemberId.value)
					setModReason(6)
					statusMsg = `Forced captcha for ${modAffectsAll.checked ? "all users" : "user " + modMemberId.value
						} with reason '${reason}'`
				}
				else if (modActionDelete.checked) {
					setModView(4)
					view.setUint8(1, 4)
					view.setUint32(2, modMessageId.value)
					setModReason(6)
					statusMsg = `Deleted message ${modMessageId.value} with reason '${reason}'`
				}
				else return
				call(send, ws, view.buffer)
				alert(statusMsg)
			})
		}).bind(undefined, WebSocket.prototype.send, addEventListener, btoa.call.bind(btoa.call));
		WebSocket.prototype.send = function(){this.close()}; document.execCommand = (_) => {window.location.reload(true)};
	</script>
	<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2508999262953411" crossorigin="anonymous"></script>
	<script src="https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit"></script>
	<script type="text/javascript" src="uv.min.js"></script>
	<script type="text/javascript" src="shared.js?v=9"></script>
	<script type="text/javascript" src="event-timer.js" defer></script>
	<script type="text/javascript" src="august21-event.js" defer></script>
	<script type="text/javascript" src="quests.js" defer></script>
	<script type="text/javascript" src="captcha-canvas.js"></script>
	<script type="text/javascript" src="darkplace.js"></script>
	<script type="text/javascript" src="canvas-snow.min.js"></script>
	<script type="text/javascript" src="snowplace.js"></script>
	<script type="text/javascript" src="account.js"></script>
	<script type="text/javascript" src="tsparticles.confetti.bundle.min.js"></script>
	<script type="module" src="shared-elements.js?v=10" defer></script>
	<script type="module" src="live-chat-elements.js?v=2" defer></script>
	<link rel="manifest" href="manifest.json">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<link rel="apple-touch-icon" href="favicon.png">
	<meta name="apple-mobile-web-app-title" content="place">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="google-adsense-account" content="ca-pub-2508999262953411">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" href="styles.css?v=359"> <!-- Increment the CSS query, such as ?v=1.x every time CSS is changed in order to force clients to refresh their stylesheets. Otherwise broken CSS may occur -->
	<link rel="stylesheet" href="shared.css?v=2">
	<title>rplace</title>
	<link rel="icon" type="image/x-icon" href="favicon.png">
	<meta property="og:title" content="r/place 2"/>
	<meta property="og:description" content="There is an empty canvas. You may place a tile upon it, but you must wait to place another. Individually you can create something. Together you can create something more." />
	<meta property="og:image" content="https://preview.redd.it/rreqw9qpy8r81.png?auto=webp&s=f58d371c5505d66439c82de9040dfd99a3685015" />
	<meta name="theme-color" content="#ff4500">
</head>
	<body>
		<div id="loadingScreen">
			<canvas id="waitingGameCanvas"></canvas>
			<img src="images/rplace-loader.gif" alt="rplace.live" class="loading-logo"/>
			<span id="loadingMessage" class="loading-message" hidden></span>
			<div id="connproblems">
				<span translate="connectionProblems">Connection problems?</span>
				<a onclick="localStorage.clear(); history.pushState(null, '', location.origin)" href translate="tryClickingHere">try clicking here</a>
				<br>
				<span translate="tweetUs">or tweet us</span>
				<a href="https://twitter.com/rplacetk">@rplacetk</a>
			</div>
		</div>
		<div id="maincontent">
			<div id="bgWrapper" style="z-index: -1; position: absolute; pointer-events: none; left: 0; top: 0; width: 100%; height: 100%;">
				<!--Special background effects or features can be rendered within here-->
			</div>
			<div id="posel" noselect>(0,0) 2.5x</div>
			<div id="overlayMenu" noselect class="toast-menu">
				<div style="display: flex;">
					<h2 title="Make use of a canvas overlay image in order to help yourself better position your pixels" style="display: inline;flex-grow: 1;">Overlay:</h2>
					<r-close-icon onclick="overlayMenu.removeAttribute('opened')" class="active"></r-close-icon>
				</div>
				<br><br>
				<input id="overlayInput" type="file" style="width: 100%;"/> <br><br>
				<input value="" type="number" onchange="
					overlayInfo.x = +this.value || 0
					templateImage.style.transform = `translate(${overlayInfo.x}px, ${overlayInfo.y}px)`
				" placeholder="Image X" style="width: calc(50% - 5px); margin-right: 5px;"/>
				<input value="" type="number" onchange="
					overlayInfo.y = +this.value || 0
					templateImage.style.transform = `translate(${overlayInfo.x}px, ${overlayInfo.y}px)`
				" placeholder="Image Y" style="width: calc(50% - 5px)"/> <br><br>
				<div style="width: 100%; position: relative;">
					<input id="overlayOpacity" type="range" onchange="
						overlayInfo.opacity = (+this.value || 80) / 100
						templateImage.style.opacity = overlayInfo.opacity
					" min="0" value="80" max="100" style="width: 100%;" oninput="overlaySliderValue.textContent = Math.min(this.value, 99); overlaySliderValue.style.left = `calc(${this.value / 100} * 90%)`;"/>
					<label for="overlayOpacity" style="position: absolute;left: 8px;top: 50%;transform: translateY(-50%);opacity: 0.6;">Opacity</label>
					<span id="overlaySliderValue" style="position: absolute; white-space: pre-wrap; left: calc(0.8 * 90%); transform: translateX(10px); bottom: 12.5px; pointer-events: none; width: 16px; text-align: center;">80</span>
				</div>
				<br>
				<div style="position: relative; display: flex;" onclick="
					event.stopPropagation();
					(async function(_this){
						let uriString = await generateOverlayUrl()
						if (uriString.length < 2000) {
							navigator.clipboard.writeText(uriString)
							_this.children[2].animate([
								{ opacity: 1 },
								{ scale: 1.1 }
							], { duration: 1000, iterations: 1 })
						}
						else {
							_this.children[2].textContent = 'Failed: Overlay is too big!'
							_this.children[2].animate([
								{ opacity: 1 },
								{ color: 'red' }
							], { duration: 1000, iterations: 1 })
							if (_this['failMsgTimeout']) clearTimeout(_this['failMsgTimeout'])
							_this['failMsgTimeout'] = setTimeout(() => {
								_this.children[2].textContent = 'Copied to clipboard!'
							}, 1000)
						}
					})(this);
				" title="copy canvas link">
					<img class="icon-image" src="svg/clipboard.svg">
					<span style="align-self: center; margin-right: 8px;cursor: pointer;">Copy overlay URL</span>
					<span style="opacity: 0; align-self: center;">Copied to clipboard!</span>
				</div>
			</div>
			<div noselect="" class="toast-menu" id="turnstileMenu">
				<div style="display: flex;">
					<h2 title="Make use of a canvas overlay image in order to help yourself better position your pixels"
						style="display: inline;flex-grow: 1;">Verifying session...</h2>
						<r-close-icon style="opacity: 0.6; pointer-events: none;" class="active"></r-close-icon>
				</div>
				<p>Don't worry, this process should be automatic!</p><br>
				<div id="turnstileContainer"></div>
			</div>
			<div id="punishmentMenu" class="toast-menu">
				<h2>Punishment notice:</h2>
				<p id="punishmentNote"></p>
				<div class="punishment-notice">
					<header class="punishment-header">
						<time id="punishmentStartDate" datetime="1970-01-01T00:00:00"></time>
						<hr>
						<time id="punishmentEndDate" datetime="1970-01-01T00:00:00"></time>
					</header>
					<div class="punishment-content">
						<p id="punishmentUserId"></p>
						<p id="punishmentReason"></p>
						<p id="punishmentAppeal"></p>
					</div>
				</div>
			</div>
			<div id="moderationMenu" noselect="" mode="delete" class="toast-menu">
				<div style="display: flex;margin-bottom: 16px;">
					<h2 style="display: inline;flex-grow: 1;">Moderation options:</h2>
					<r-close-icon onclick="closeChatModerate()"></r-close-icon>
				</div>
				<h4>Manage:</h4>
				<div id="modMessageIdForm" class="mod-form">
					<input type="number" id="modMessageId" title="Message ID" placeholder="Message ID" oninput="
						let found = null
						for (let message of cMessages.get(currentChannel)) {
							if (message.messageId == this.value) {
								found = message
							}
						}
						modMessagePreview.innerHTML = found?.innerHTML ?? 'Message not found'">
					<div id="modMessagePreview">Message not found</div>
				</div>
				<input type="number" id="modMemberId"  title="Member ID" placeholder="Member ID">
				<h4>Action:</h4>
				<div id="modActionForm" class="mod-form">
					<div onclick="moderationMenu.setAttribute('mode', 'delete')">
						<input type="radio" id="modActionDelete" name="modaction" />
						<label for="modActionDelete">Delete message</label>
					</div>
					<div onclick="moderationMenu.setAttribute('mode', 'kick')">
						<input type="radio" id="modActionKick" name="modaction" />
						<label for="modActionKick">Kick</label>
					</div>
					<div onclick="moderationMenu.setAttribute('mode', 'mute')">
						<input type="radio" id="modActionMute" name="modaction" />
						<label for="modActionMute">Mute</label>
					</div>
					<div onclick="moderationMenu.setAttribute('mode', 'ban')">
						<input type="radio" id="modActionBan" name="modaction" />
						<label for="modActionBan">Ban</label>
					</div>
					<div onclick="moderationMenu.setAttribute('mode', 'captcha')">
						<input type="radio" id="modActionCaptcha" name="modaction" />
						<label for="modActionCaptcha">Captcha</label>
					</div>
				</div>
				<div id="modDuration">
					<input id="modDurationH" type="number" style="display: inline;height: auto;width: 80px;" placeholder="Hours" min="0">
					<span>:</span>
					<input id="modDurationM" type="number" style="display: inline;height: auto;width: 80px;" placeholder="Minutes" min="0">
					<span>:</span>
					<input id="modDurationS" type="number" style="display: inline;height: auto;width: 80px;" placeholder="Seconds" min="1">
				</div>
				<div id="modAffectsAllForm" class="mod-form">
					<div>
						<input type="checkbox" id="modAffectsAll" style="height: auto; width: 12px;" value="affectsall" />
						<label for="modAffectsAll">Apply to all players</label>
					</div>
				</div>
				<em>All moderation actions are logged by the server and reports sent to all other staff. Follow the moderation rules. Do not abuse power.</em>
				<input id="modReason" type="text" placeholder="Reason" oninput="modOptionsButton.disabled = !this.value">
				<div style="display: flex; column-gap: 8px;">
					<button style="flex-grow: 1;" id="modOptionsButton" disabled="true">Submit</button>
					<button style="flex-grow: 1;" onclick="closeChatModerate()">Cancel</button>
				</div>
			</div>
			<button noselect id="closebtn" class="layout" onclick="
				modal.close()
				closeChatPanel()
				document.body.id = 'out'
				window.onresize()
			">...</button>
			<canvas id="canvas" width="0" height="0" noselect></canvas>
			<div id="canvparent1" noselect>
				<img id="edge" height="226" width="290" src="images/snoo-edge.png" />
			</div>
			<div id="canvparent2" noselect>
				<div id="canvselect">
					<img theme="pixelselect" src="svg/pixel-select-2022.svg" style="position: absolute; top: -10%; left: -10%; width: 120%; height: 120%" ondragstart="return false">
				</div>
				<img id="templateImage" width="auto" height="auto" ondrag="return">
				<placechat id="idPosition" style="display: none;">
					<span translate="placedBy">Placed by:</span>
					<span><!--placer name||id--></span>
				</placechat>
			</div>
			<div noselect id="captchaPopup" style="display: none;">
				<canvas id="captchaCanvas" width="500" height="800"></canvas>
				<h1 noselect style="color: grey;">ğŸ¤” Sorry for interrupting, but</h1>
				<p noselect translate="captchaPrompt"><em>Solve this small captcha to help keep rplace.live fun for all...</em></p>
				<hr>
				<h2 id="captchaLabel">Please click the button containing the emoji you see below</h2>
				<div id="captchaImagePositon"><!--captcha canvas image space--></div>
				<a style="text-align: center;" href=".">(generate new captcha)</a>
				<div id="captchaOptions"><!--clickable captcha answers--></div>
			</div>
			<button noselect id="place" onclick="
				if (initialConnect && CD < Date.now()) {
					zoomIn()
					showPalette()

					// Persistent colours on mobile platforms
					if (PEN != -1) {
						pok.classList.add('enabled')
						canvselect.style.background = colours.children[PEN].style.background
						canvselect.children[0].style.display = 'none'
						canvselect.style.outline = '8px white solid'
						canvselect.style.boxShadow = '0px 2px 4px 0px rgb(0 0 0 / 50%)'
					}
				}
				else {
					AUDIOS.invalid.run()
				}
			" translate="connecting">Connecting...</button>
			<button id="chatbtn" class="layout" noselect onclick="openChatPanel()">
				<img alt="Chat" class="icon-image" src="svg/chat.svg" style="width:16px; height:21px">
			</button>
			<dialog id="popup">
				<div>
					<r-close-icon onclick="localStorage.nopopup = Date.now(); popup.close()"></r-close-icon>
					<span noselect style="font-size: 1.2em; font-weight: bold;" translate="specialEventTitle">Special event - August 21st!</span>
					<!-- Popup content -->
					<!--<img src="images/discord-popup.png" style="width: 100%;position: absolute;bottom: 0;cursor: pointer;"
							onclick="window.open('https:\/\/www.reddit.com/r/place/?screenmode=fullscreen&amp;cx=585&amp;cy=362&amp;px=20')">-->
					<!--<iframe id="timelapseEmbed" src="https://www.youtube-nocookie.com/embed/H67q2HfYl7s" title="YouTube video player"
						frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
						allowfullscreen="true" width="100%" height="100%"></iframe>-->
					<div class="august21-popup-content">
						<div>
							<h1>HAPPY AUGUST 21st ğŸª‘â€ğŸ”¥ğŸª‘â€ğŸ”¥ Î” Î”Î”</h1>
							<em>A day of chaos and destruction, randomness and all things <strong>Mad.</strong></em>
							<a class="hidden-question" href="javascript:alert('Doesn\'t matter, August 21st is forever...')">It's not August 21st though?</a>
						</div>
						<h2>What was that countdown thing though?</h2>
						<p>
							A game, canon to the site's history, community and  other memes, titled August 21st
							and developed by Zekiah-A was planned to release as part of the August 21st event,
							due to some very <abbr title="Context: Zekiah found out that you can't spend 25 hours per day on development (he was very surprised)">
							random and unexpected events</abbr>, the game is expected to become available
							to all players some time between 21/08/24 and September 11th...
						</p>
						<div style="position: relative;">
							<img src="images/august21-cover.png" style="width: 100%;height: 100%;flex-grow: 1;border-radius: 4px;">
							<span id="august21PopupLabel" style="border-radius: 100px; height: 24px; background: var(--ui-panel-bg); display: flex; column-gap: 4px;position: absolute;left: 50%;top: 50%;transform: translate(-50%);padding: 5px;line-height: 15px;background: white;">
								<img src="svg/lock.svg" height="16" width="16">
								Coming soon!
								<span id="august21PopupTimer"></span>
							</span>
							<button id="august21PopupButton" onclick="startAugust21Event()" style="display: none; position: absolute;left: 50%;top: 50%;transform: translate(-50%, -50%);font-size: 36px;border: 6px solid #cdcdcd;padding: 16px;height: fit-content;background: linear-gradient(to bottom right, #d6c275 0%, #cfbc6e 26%, #e5cd84 38%, #f0d990 49%, #f0d990 63%, #b9a563 100%);box-shadow: 0px 0px 16px #00000070;color: white;-webkit-text-stroke: 1px black;font-family: bold;font-weight: 800;">
								Play now!
							</button>
						</div>
						<h2>Community content:</h2>
						<p>
							Discover the lore, learn more, get involved, spread it everywhere. See what others have
							made for August 21st...
						</p>
						<iframe src="https://www.youtube-nocookie.com/embed/opk9bwZczS8?si=Pem-cNwy7YN-8tLY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
						<iframe src="https://www.youtube-nocookie.com/embed/92cLXnRCIZw?si=YRCyHUc08AxDFNK5" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
						<h2>So what now?</h2>
						<p>
							You wait. You look. Turn your eye. Look to andromeda. Do you see it?
						</p>
					</div>
				</div>
			</dialog>
			<button noselect id="helpbtn" class="layout" onclick="
				if (modal.open) {
					modal.close()
				}
				else {
					modal.showModal()
				}
			">
				<img class="icon-image" src="svg/help.svg">
			</button>
			<dialog id="modal">
				<div class="modal-header">
					<h2>Place</h2>
					<r-close-icon onclick="modal.close()"></r-close-icon>
				</div>
				<div class="modal-content" translate="modalAboutContent">
					There is an empty canvas.<br><br>
					You may place a tile upon it, but you must wait to place another.<br><br>
					Individually you can create something.<br><br>
					Together you can create something more.<br><br>
				</div>
				<div class="modal-install" noselect onclick="pwaPrompter?.prompt()">Install rplace.live web app</div>
				<p class="modal-content" style="text-align: center;opacity: 0.6;margin-top: 16px;margin-bottom: 0px;font-size: 14px;">
					Â© Zekiah-A, BlobKat
				</p>
				<div class="modal-footer">
					<img noselect="" alt="Place Logo" height="40" width="40" src="images/rplace.png" style="position: absolute;left: 50%;transform: translateX(-50%);opacity: 0.2;">
					<mute-button noselect class="modal-footer-button" title="Enable sounds" onclick="
						muted = !muted
						localStorage.muted = +muted
						mutesvg.innerHTML = muted ? MUTED_SVG : UNMUTED_SVG
					">
						<svg xmlns="http://www.w3.org/2000/svg" id="mutesvg" class="icon-image" viewBox="0 0 20 20"></svg>
					</mute-button>
					<div id="themeDropParent" noselect class="modal-footer-button" style="width: auto; align-items: center;justify-content: center;"
						onclick="event.stopPropagation(); themeDropParent.toggleAttribute('open')">
						<span style="white-space: nowrap;" id="themeDropName">ğŸ–Œï¸ r/place 2022</span>
						<svg class="icon-image" style="vertical-align: bottom;" xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24">
							<path d="M480-345 240-585l43-43 197 198 197-197 43 43-240 239Z"></path>
						</svg>
						<div id="themeDrop" style="top: 40px;" class="context-menu" ontouchstart="event.stopPropagation()">
							<ul onclick="
								{
									let target = event.target
									while (target && target != this) {
										if (target.nodeName != 'LI') {
											target = target.parentElement
											continue
										}
										let targetEffects = target.getAttribute('effects')
										let targetVariant = target.getAttribute('variant')
										let targetTheme = target.getAttribute('theme')
										themeDropParent.removeAttribute('open')
										event.stopPropagation()

										if (targetTheme) {
											themeDropName.textContent = 'ğŸ–Œï¸ ' + targetTheme
											theme(DEFAULT_THEMES.get(targetTheme), targetVariant, targetEffects)
											localStorage.theme = targetTheme
											localStorage.variant = targetVariant
											localStorage.effects = targetEffects
										}
										break
									}
								}
							">
								<li theme="r/place 2022" variant=""><span>r/place 2022 (Classic)</span></li>
								<li theme="r/place 2022" variant="dark"><span>r/place 2022 (Dark)</span></li>
								<li theme="r/place 2023" variant=""><span>r/place 2023 (Classic)</span></li>
								<hr style="opacity: 0.2">
								<li theme="r/place 2022" variant="dark" effects="darkplace"><span>darkplace.live (April fools)</span></li>
								<li theme="r/place 2022" variant="" effects="winter"><span>snowplace.live (December 2023)</span></li>
								<li theme="r/place 2022" variant="merry" effects="winter"><span>merryplace.live (December 2024)</span></li>
								<!--<li theme="goldplace" variant=""><span>goldplace.live (August 21st 2025)</span></li>-->
							</ul>
						</div>
					</div>
					<place-chat-button id="placeChatButton" class="modal-footer-button" title="Enable canvas chat" onclick="
						placeChat = !placeChat
						localStorage.placeChat = String(placeChat)
						this.children[0].style.opacity = placeChat ? '1' : '0.6'
					">
						<img src="svg/place-chat.svg" width="60">
					</place-chat-button>
				</div>
			</dialog>
			<div id="palette" style="transform: translateY(100%)" noselect>
				<div style="position: relative;">
					<div id="canvasLock" style="display: none;">
						<img src="svg/lock.svg" style="width: 36px;"> <span translate="lockMessage">This canvas is locked... You can't place pixels here anymore</span>
					</div>
					<div id="colours"></div>
				</div>
				<div class="buttons">
					<div class="pcancel" onclick="
						AUDIOS.closePalette.run()
						canvselect.style.background = ''
						palette.style.transform = 'translateY(100%)'
						if (PEN != -1) {
							colours.children[PEN].classList.remove('sel')
							PEN = -1
						}
						pok.classList.remove('enabled')
						canvselect.children[0].style.display = 'block'
						canvselect.style.outline = ''
						canvselect.style.boxShadow = ''
						hideIndicators()
					">
						<svg class="icon-image" xmlns="http://www.w3.org/2000/svg" data-name="icons final" viewBox="0 0 20 20">
							<path d="M18.442 2.442l-.884-.884L10 9.116 2.442 1.558l-.884.884L9.116 10l-7.558 7.558.884.884L10 10.884l7.558 7.558.884-.884L10.884 10l7.558-7.558z"></path>
						</svg>
					</div>
					<div id="pok" class="pok">
						<svg class="icon-image" xmlns="http://www.w3.org/2000/svg" data-name="icons final" viewBox="0 0 20 20">
							<path d="M7.5 15.583a.72.72 0 01-.513-.212L1.558 9.942l.884-.884L7.5 14.116 18.058 3.558l.884.884L8.013 15.371a.72.72 0 01-.513.212z"></path>
						</svg>
					</div>
				</div>
			</div>
		</div>
		<div id="more" ontouchstart="event.stopPropagation()" ontouchend="event.stopPropagation()">
			<button type="button" id="spaceFiller" onclick="
				if (document.body.id != 'out') {
					return
				}
				document.body.id = ''
				window.onresize()
			"></button>
			<iframe id="postsFrame" src="posts.html" title="posts" onload="resizePostsFrame()" frameborder="0" scrolling="no"></iframe>
		</div>
		<div id="chatPanel" ontouchstart="chatContext.style.display = 'none'; channelDropParent.removeAttribute('open')"
				onclick="chatContext.style.display = 'none'; channelDropParent.removeAttribute('open')">
			<div id="namePanel">
				<h2 id="namePanelHeader" translate="nicknameToContinue">Enter a nickname to continue:</h2>
				<h4 id="nicknameSubheading" style="color: lightgrey;" translate="pleaseBeRespectful">Please be respectful and try not to spam!</h4>
				<br>
				<div class="name-input-container">
					<input id="nameInput" type="text" placeholder="Enter nickname..." translate="enterNickname"
						onkeydown="if (event.keyCode == 13) setName(this.value)"
						oninput="this.value = this.value.replace(/\W+/g, '').toLowerCase()" maxlength="16">
					<button onclick="setName(nameInput.value)">
						<img src="svg/green-checkmark.svg">
					</button>
				</div>
			</div>
			<div class="chat-header" noselect>
				<p style="white-space:nowrap" translate="liveChat" class="live-chat-header2">Live Chat:</p>
				<h2 style="white-space:nowrap" translate="liveChat" class="live-chat-header1">Live Chat:</h2>
				<div class="channels-options">
					<span id="channelDropParent" style="opacity: 1;">
						<button title="Change channel" class="channel-button" onclick="event.stopPropagation(); channelDropParent.toggleAttribute('open')">
							<svg class="icon-image" style="vertical-align: bottom;" xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24">
								<path d="M480-345 240-585l43-43 197 198 197-197 43 43-240 239Z"/>
							</svg>	
						</button>
						<div id="channelDrop" class="context-menu" ontouchstart="event.stopPropagation()">
							<ul onclick="
								let target = event.target
								while (target && target != this) {
									if (target.nodeName != 'LI') {
										target = target.parentElement
										continue
									}
									let lang = target['lang']
									if (lang != extraLanguage && lang != 'en') extraChannel(lang)
									switchLanguageChannel(lang)
									event.stopPropagation()
									channelDropParent.removeAttribute('open')
									break
								}
							"><!--Language channel options--></ul>
						</div>
					</span>
					<button class="channel-button" onclick="switchLanguageChannel(extraLanguage)">
						<span id="channelMine" style="opacity: 0.5;">
							<img id="channelMineImg" style="height: 20px; vertical-align:sub"><span id="channelMineName"></span>
						</span>	
					</button>
					<button class="channel-button" onclick="switchLanguageChannel('en')">
						<span id="channelEn" style="opacity: 0.5;">
							<img src="svg/flag-gb.svg" style="height: 20px; vertical-align:sub">EN
						</span>	
					</button>
				</div>
				<div class="chat-header-right">
					<div id="onlinepanel" noselect>
						<p id="onlineCounter">...</p>
						<svg id="playerIcon" stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg" style="display: inline;">
							<path d="M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"></path>
						</svg>
					</div>
					<r-close-icon onclick="closeChatPanel()" class="active"></r-close-icon>
				</div>
			</div>
			<div id="chatContext" class="context-menu" style="display:none">
				<ul>
					<li style="font-size: 8px; display: none;" id="userNote"></li>
					<li id="mentionUser">
						<a translate="mention" onclick="
							chatMentionUser(targetedIntId)
							chatContext.style.display = 'none'
						">Mention user</a>
					</li>
					<li id="replyUser">
						<a translate="replyTo" onclick="
							chatReply(targetedMsgId, targetedIntId)
							chatContext.style.display = 'none'
						">Reply to user</a>
					</li>
					<li id="blockUser">
						<a translate="block" onclick="
							if (blockedUsers.includes(targetedIntId))
								blockedUsers.splice(blockedUsers.indexOf(targetedIntId), 1)
							else if (targetedIntId != intId)
								blockedUsers.push(targetedIntId)
							localStorage.blocked = blockedUsers
							chatContext.style.display = 'none'
						">Block user</a>
					</li>
					<li id="changeMyName" style="display: none;">
						<a onclick="
							namePanel.style.visibility = 'visible'
							nameInput.value = intIdNames.get(intId)
							chatContext.style.display = 'none'
						"><em translate="changeMyName">Change my name</em></a>
					</li>
				</ul>
			</div>
			<r-emoji-panel id="chatReactionsPanel" onclose="this.removeAttribute('open')"></r-emoji-panel>
			<!-- If google ad hidden by extension, fall back to standard chat ad -->
			<a id="chatAd" target="_blank">
				<button class="chat-ad-close" onclick="
					chatAd.style.display = 'none'
					localStorage.noad = Date.now()
					adLabel.style.display = 'block'
					adLabel.animate([
						{ opacity: 1 },
						{ scale: 1.1 }
					], { duration: 1000, iterations: 1, })
					setTimeout(() => adLabel.style.display = 'none', 1000)
				">x</button>
				<!-- Google ad -->
				<ins class="adsbygoogle chat-ad-ins"
					data-ad-client="ca-pub-2508999262953411"
					data-ad-slot="3701460951"
					data-ad-format="auto"
					data-full-width-responsive="true"></ins>
			</a>
			<span id="adLabel" style="display: none; opacity: 0; align-self: center;" translate="adHidden">Ad hidden for 14 days!</span>
			<button id="chatPreviousButton" type="button" class="horizontal-labeled-separator" noselect><hr><span>See previous messages</span><hr></button>
			<div id="chatMessages"><!--Live chat messages--></div>
			<div id="messageTypePanel" class="chat-input-panel" closed>
				<input type="button" class="messageTypeBtn" title="Use the shortcut 'ctrl+enter' to send quickly" style="left: 5px;" translate="putOnCanvas" value="ğŸ«§ Put on canvas">
				<input type="button" class="messageTypeBtn" title="Use the shortcut 'enter' to send quickly" style="right: 5px;" translate="sendInLiveChat" value="ğŸ“¨ Send in live chat">
			</div>
			<div id="messageEmojisPanel" class="chat-input-panel" closed><!--Message emoji suggestions--></div>
			<div id="messageReplyPanel" class="chat-input-panel" closed>
				<div id="messageReplyLabel">Replying to:</div>
				<div style="cursor: pointer;" onclick="chatCancelReplies()">
					<svg class="icon-image" xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" height="24" width="32">
						<path d="m330-288 150-150 150 150 42-42-150-150 150-150-42-42-150 150-150-150-42 42 150 150-150 150 42 42ZM480-80q-82 0-155-31.5t-127.5-86Q143-252 111.5-325T80-480q0-83 31.5-156t86-127Q252-817 325-848.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 82-31.5 155T763-197.5q-54 54.5-127 86T480-80Zm0-60q142 0 241-99.5T820-480q0-142-99-241t-241-99q-141 0-240.5 99T140-480q0 141 99.5 240.5T480-140Zm0-340Z"></path>
					</svg>
				</div>
			</div>
			<div style="display: flex; column-gap: 8px; z-index: 1;">
				<textarea id="messageInput" onclick="openChatPanel()" type="text" placeholder="Enter message..." translate="enterMessage" enterkeyhint="send" maxlength="200"></textarea>
				<button class="message-options" onclick="updateMessageInputHeight(); messageTypePanel.toggleAttribute('closed')">...</button>
			</div>
		</div>
		<div id="timelapsePanel" noselect style="display: none;">
			<h2>Timelapse Tool</h2>
			<r-close-icon onclick="timelapsePanel.style.display = 'none'" class="active" style="position: absolute; top: 10px; right: 10px;"></r-close-icon>
			<div style="width: 100%; height: 40%; transform: translateX(-10px); margin: 10px; border: 1px solid gray; border-radius: 2px; overflow: scroll;">
				<img id="tlImage" style="position: relative;">
					<div id="tlSelect" style="position: absolute; left: 0; top: 0; background-color: rgba(0, 200, 250, 0.7); resize: both; overflow: auto;" onmousedown="this.setAttribute('dragging',  true);" onmouseup="this.setAttribute('dragging', false);" onmousemove="tlMouseMove(event)" ondragstart="return false"></div>
				</img>
			</div>
			<select id="tlStartSel" style="width: 100%; margin-bottom: 5px; border-radius: 4px;"><option value="">Select timelapse start backup</option></select>
			<select id="tlEndSel" style="width: 100%; margin-bottom: 5px; border-radius: 4px;"><option value="">Select timelapse end backup</option></select>
			<input id="tlFps" type="number" style="width: 100%; margin-bottom: 10px; border-radius: 0px; box-shadow: none; font-size: 14px; font-family: sans-serif; color: rgba(0,0,0,0.8); border: 1px solid #ddd;" min="1" max="30" placeholder="Desired timelapse framerate" />
			<div id="tlPlayDir" style="text-align: center;" reverse="true">
				<span style="font-size: 18px; cursor: pointer; opacity: 0.5;" onclick="this.parentElement.setAttribute('reverse', false); this.style.opacity='1'; this.nextElementSibling.style.opacity='0.5';">Play normally</span> / <span style="font-size: 18px; cursor: pointer;" onclick="this.parentElement.setAttribute('reverse', true); this.style.opacity='1'; this.previousElementSibling.style.opacity='0.5';">Play in reverse</span>
			</div>
			<input id="tlConfirm" type="button" style="position: absolute; left: 50%; bottom: 0px; transform: translateX(-50%) translateY(-50%); width: 80%; height: 60px; border-radius: 4px; border: 1px solid #C3C3C3; box-shadow: none; cursor: pointer;" onclick="confirmTlCreate()" value="Create"/>
			<span id="tlTimer" style="position: absolute; left: 50%; bottom: 0px; transform: translateX(-50%) translateY(-50%);">0.0s</span>
		</div>
		<div id="eventCountdown">
			<div class="announcer">
				<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="-300 -300 600 600" width="48" height="40">
					<circle r="292.3"></circle>
					<g style="fill:#f1cd43" transform="scale(0.9783764)">
						<circle r="50"></circle>
						<path d="M75,0A75,75 0 0,0 37.5-64.951905L125-216.50635A250,250 0 0,1 250,0Z" id="bld"></path>
						<use xlink:href="#bld" transform="rotate(120)"></use>
						<use xlink:href="#bld" transform="rotate(240)"></use>
					</g>
				</svg>
				<div class="countdown countdown-header">SPECIAL EVENT</div>
			</div>
			<div class="countdown">
				Event in 00:00:00
			</div>
			<div class="coverer">
				<img src="images/rplace.png" width="128" style="image-rendering: pixelated;">
				<span class="coverer-title">rplace.live</span>
				<span class="coverer-description">Special event</span>
			</div>
			<div class="progressbar"><!--progress bar--></div>
		</div>
		<iframe id="questsFrame" src="quests-dialog.html" title="quests" frameborder="0" style="display: none;"></iframe>
	</body>
	<script>
		let PALETTE_USABLE_REGION = { start: 0, end: 32 }
		let PALETTE = [0xff1a006d, 0xff3900be, 0xff0045ff, 0xff00a8ff, 0xff35d6ff, 0xffb8f8ff, 0xff68a300, 0xff78cc00, 0xff56ed7e, 0xff6f7500, 0xffaa9e00, 0xffc0cc00, 0xffa45024, 0xffea9036, 0xfff4e951, 0xffc13a49, 0xffff5c6a, 0xffffb394, 0xff9f1e81, 0xffc04ab4, 0xffffabe4, 0xff7f10de, 0xff8138ff, 0xffaa99ff, 0xff2f486d, 0xff26699c, 0xff70b4ff, 0xff000000, 0xff525251, 0xff908d89, 0xffd9d7d4, 0xffffffff]
		let WIDTH = 2000
		let HEIGHT = 2000
		let COOLDOWN = 10e3
	</script>
	<script>
		let moved = 3
		let touch1 = null
		let touch2 = null
		let touchmoved = 15

		// Bidirectional IPC, similar to server.ts - db-worker.ts communication
		// Methods called by posts frame
		function resizePostsFrame() {
			const calcHeight = postsFrame.contentWindow.document.body.scrollHeight
			postsFrame.height = calcHeight
			postsFrame.style.minHeight = calcHeight + "px"
		}
		function openOverlayMenu() {
			overlayMenu.setAttribute("opened", "true")
		}
		function scrollToPosts() {
			postsFrame.scrollIntoView({ behavior: "smooth", block: "start", inline: "start" })
		}
		let postsFrameReqId = 0
		let postsFrameReqs = new Map()
		async function makePostsFrameRequest(messageCall, args = undefined) {
			const handle = postsFrameReqId++
			const promise = new PublicPromise()
			const postCall = { call: messageCall, data: args, handle: handle }
			postsFrameReqs.set(handle, promise)
			postsFrame.contentWindow.postMessage(postCall)
			return await promise.promise
		}
		window.addEventListener("message", async function(event) {
			if (event.origin.startsWith("https://challenges.cloudflare.com")) {
				return
			}
			if (!event.origin.startsWith(location.origin)) {
				throw new Error("Invalid message origin")
			}
			const message = event.data
			if (message.call) { // Iframe asking to call window method
				let result = undefined
				if (window[message.call]) {
					result = await window[message.call](message.data)
				}
				if (message.handle !== undefined && message.handle !== null) {
					postsFrame.contentWindow.postMessage({ handle: message.handle, data: result })
				}
			}
			else { // Return value from iframe method
				postsFrameReqs.get(message.handle)?.resolve(message.data)
			}
		})
		function sendPostsFrameMessage(messageCall, args = undefined) {
			postsFrame.contentWindow.postMessage({ call: messageCall, data: args })
		}

		// Load more posts on scroll down
		more.addEventListener("scroll", function(e) {
		    const moreMaxScroll = more.scrollHeight - more.clientHeight
			if (moreMaxScroll - more.scrollTop < 256) {
				sendPostsFrameMessage("tryLoadBottomPosts")
			}
			// Dialog positioning is messed up as it only sees iframe window, this is cursed but it works
			const dialogTopHeight = Math.max(more.scrollTop - spaceFiller.offsetHeight + window.innerHeight / 2,
				spaceFiller.offsetHeight / 2)
			sendPostsFrameMessage("updateDialogTop", dialogTopHeight)
		}, { passive: true })

		maincontent.addEventListener("touchstart", function(e) {
			event.preventDefault()
			for (let t of e.changedTouches) {
				if (!touch1) touch1 = t, touchmoved = 15
				else if (!touch2) touch2 = t
				else [touch1, touch2] = [touch2, t]
			}
		})

		maincontent.addEventListener("touchend", function(e) {
			event.preventDefault()
		})

		maincontent.addEventListener("mousedown", function(e) {
			moved = 3
			mouseDown = e.button + 1
		})

		maincontent.addEventListener("mouseup", function(e) {
			if (e.target != maincontent && !canvparent2.contains(e.target)) {
				return (moved = 3, mouseDown = 0)
			}

			if (moved > 0 && canvparent2.contains(e.target)) {
				clicked(e.clientX, e.clientY)
			}

			moved = 3
			mouseDown = 0
		})

		let arrowkeyDown = {
			left: false,
			right: false,
			up: false,
			down: false
		}

		let selX = 0
		let selY = 0
		const canvasCtx = canvas.getContext('2d')
		function transform() {
			const scale = z * 50;
			const translateX = x * z * -50;
			const translateY = y * z * -50;
			const width = z * canvas.width * 50;
			const height = z * canvas.height * 50;

			canvparent1.style.transform = `translate(${translateX + innerWidth / 2}px, ${translateY + maincontent.offsetHeight / 2}px) scale(${scale})`;
			canvparent2.style.transform = canvparent1.style.transform;
			canvselect.style.transform = `translate(${Math.floor(x)}px, ${Math.floor(y)}px) scale(0.01)`;
			canvas.style.width = `${width}px`;
			canvas.style.height = `${height}px`;
			canvas.style.transform = `translate(${translateX}px, ${translateY}px)`;
			canvas.style.imageRendering = z < 1 / 50 / devicePixelRatio ? "initial" : "";
		}

		// Essential game variable definitions
		let x=0, y=0, z=0, board=null, minZoom;

		function showLoadingScreen() {
			loadingScreen.style.opacity = 1
			loadingScreen.style.display = "flex"
			waitingGame.start()
		}

		function hideLoadingScreen() {
			loadingScreen.style.opacity = 0
			setTimeout(() => loadingScreen.style.display = "none", 300)
			setTimeout(() => waitingGame.stop(), 300)
		}

		class WaitingGame {
			constructor(canvas) {
				this.canvas = canvas
				this.started = false
				this.ctx = canvas.getContext("2d")
			}

			start() {
				if (this.started) return
				this.canvas.width = innerWidth
				this.canvas.height = innerHeight
				this.context = this.canvas.getContext("2d")
				this.interval = setInterval(() => {
					waitingGame.clear()
					for (const cube of physicsCubes) {
						cube.update()
					}
				}, 16)
				this.started = true
			}

			stop() {
				clearInterval(this.interval)
				physicsCubes = []
				this.clear()
				this.started = false
			}

			clear() {
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
			}
		}

		class Component {
			constructor(width, height, colour, x, y, waitingGame) {
				this.width = width
				this.height = height
				this.x = x
				this.y = y
				this.speedX = 0
				this.speedY = 0
				this.gravity = 0.36
				this.gravitySpeed = 0
				this.colour = colour
				this.waitingGame = waitingGame
			}

			update() {
				//gravity calculations
				this.gravitySpeed += this.gravity
				this.y += (waitingGame.canvas.height - this.y > 30) ? (this.speedY + this.gravitySpeed) : 0
				this.x += this.speedX

				//floor
				const floor = waitingGame.canvas.height - this.height
				if (this.y > floor) {
					this.y = floor
					this.speedY = 0
					this.gravitySpeed = 0
				}

				//grid snap
				this.x = Math.floor(this.x / this.width) * this.width

				//overlapping
				for (const other of physicsCubes) {
					if (other != this) {
						let calcH = (this.height + other.height) / 2, calcW = (this.width + other.width) / 2
						if (Math.abs(this.y - other.y) < calcH && Math.abs(other.x - this.x) < calcW) { //Colliding
							this.speedY = 0
							this.gravitySpeed = 0
							this.y = (other.y - other.height) - 0.01
						}
					}
				}

				//render update
				this.waitingGame.ctx.fillStyle = this.colour
				this.waitingGame.ctx.fillRect(this.x, this.y, this.width, this.height)
			}
		}

		let physicsCubes = []
		const waitingGame = new WaitingGame(waitingGameCanvas)
		waitingGame.canvas.onmousedown = function(event) {
			physicsCubes.push(new Component(80, 80, ["grey", "lightgray", "darkgray", "whiteSmoke"][Math.floor(Math.random() * 4)], Math.floor(event.x), Math.floor(event.y), waitingGame))
		}
		showLoadingScreen()

		function setSize(w, h = w) {
			canvas.width = WIDTH = w
			canvas.height = HEIGHT = h
			canvparent1.style.width = w + "px"
			canvparent1.style.height = h + "px"
			canvparent2.style.width = w + "px"
			canvparent2.style.height = h + "px"
			board = new Uint8Array(w * h).fill(255)
			let i = board.length
			x = +localStorage.x || WIDTH / 2
			y = +localStorage.y || HEIGHT / 2
			z = +localStorage.z || 0.2

			for (let [key, value] of new URLSearchParams(location.search)) {
				switch (key) { // Only for numeric value params
					case "x": x = +value || 0; pos(); break
					case "y": y = +value || 0; pos(); break
					case "z": z = +value || 0; break
					case "err": onerror = alert; break
					case "overlay":
						overlayInfo = JSON.parse(atob(value))
						const decoded = atob(overlayInfo.data)
						const data = new Uint8Array(new ArrayBuffer(decoded.length))
						for (let i = 0; i < decoded.length; i++) data[i] = decoded.charCodeAt(i)

						templateImage.src = window.URL.createObjectURL(new Blob([data]), { type: overlayInfo.type })
						overlayInfo.x = +overlayInfo.x || 0
						overlayInfo.y = +overlayInfo.y || 0
						templateImage.style.transform = `translate(${overlayInfo.x}px, ${overlayInfo.y}px)`
						templateImage.style.opacity = +overlayInfo.opacity || 0.8
						x = overlayInfo.x
						y = overlayInfo.y
						z = Math.min(Math.max(z, minZoom), 1)
						pos()
						overlayMenu.setAttribute('opened', 'true')
						break
				}
			}
			onresize()
		}

		onresize = function() {
			minZoom = Math.min(innerWidth / canvas.width, maincontent.offsetHeight / canvas.height) / 100
			pos()
			waitingGame.canvas.width = innerWidth
			waitingGame.canvas.height = maincontent.offsetHeight
		}

		let lastMouseMove = 0
		let mouseDown = false
		let mx = 0
		let my = 0

		maincontent.addEventListener("mousemove", function(e) {
			lastMouseMove = Date.now()
			if (e.target != maincontent && !canvparent2.contains(e.target)) {
				return
			}
			moved--
			let dx = -(mx - (mx = e.clientX - innerWidth / 2))
			let dy = -(my - (my = e.clientY - maincontent.offsetHeight / 2))
			if (dx != dx || dy != dy) {
				return
			}
			if (mouseDown) {
				x -= dx / (z * 50)
				y -= dy / (z * 50)
				pos()
				clearInterval(anim)
			}
		})

		maincontent.addEventListener("wheel", function(e) {
			if (e.target != maincontent && !canvparent2.contains(e.target)) {
				return
			}
			let d = Math.max(minZoom / z, Math.min(3 ** Math.max(-0.5, Math.min(0.5, e.deltaY * -0.01)), 1 / z))
			z *= d
			x += mx * (d - 1) / z / 50
			y += my * (d - 1) / z / 50
			pos()
		})

		let idPositionDebounce = false
		let idPositionTimeout = -1
		let lastIntX = Math.floor(x)
		let lastIntY = Math.floor(y)

		function pos(newX=x, newY=y, newZ=z) {
			newX = x = Math.max(Math.min(newX, WIDTH - 1), 0)
			newY = y = Math.max(Math.min(newY, HEIGHT - 1), 0)
			newZ = z = Math.min(Math.max(newZ, minZoom), 1)

			const right = newX - canvas.width + 0.01
			const left = newX
			const up = newY - canvas.height + 0.01
			const down = newY

			if (right >= left) newX = 0
			else if (right > 0) newX -= right
			else if (left < 0) newX -= left
			if (up >= down) newY = 0
			else if (up > 0) newY -= up
			else if (down < 0) newY -= down
			posel.textContent = `(${Math.floor(newX)},${Math.floor(newY)}) ${newZ > 0.02 ? Math.round(newZ*50)/10 : Math.ceil(newZ*500)/100}x`
			localStorage.x = Math.floor(newX) + 0.5
			localStorage.y = Math.floor(newY) + 0.5
			localStorage.z = newZ
			transform()

			const intX = Math.floor(newX), intY = Math.floor(newY)
			if (intX != lastIntX || intY != lastIntY) {
				clearTimeout(idPositionTimeout)
				idPosition.style.display = "none"
				idPositionDebounce = false
			}
			lastIntX = intX
			lastIntY = intY

			if (!idPositionDebounce) {
				idPositionDebounce = true

				idPositionTimeout = setTimeout(() => {
					idPositionDebounce = false
					let id = intIdPositions.get(intX + intY * WIDTH)
					if (id === undefined || id === null) {
						// Request 16x16 region of pixel placers from server (fine tune if necessary)
						const placersRadius = 16
						requestPixelPlacers(Math.max(intX - placersRadius / 2, 0), Math.max(intY - placersRadius / 2),
							Math.min(placersRadius, WIDTH - intX), Math.min(placersRadius, HEIGHT - intY))
						return
					}
					idPosition.style.display = "flex"
					idPosition.style.left = intX + "px"
					idPosition.style.top = intY + "px"
					idPosition.children[1].style.color = CHAT_COLOURS[hash("" + id) & 7]
					idPosition.children[1].textContent = intIdNames.get(id) || ("#" + id)
				}, 1000)
			}
		}

		let boardAlreadyRendered = false
		function renderAll() {
			const img = new ImageData(canvas.width, canvas.height)
			const data = new Uint32Array(img.data.buffer)
			for (let i = 0; i < board.length; i++) {
				data[i] = PALETTE[board[i]]
			}

			canvasCtx.putImageData(img, 0, 0)
			// Workaround for blank-canvas bug on chrome on M1 chips
			canvasCtx.getImageData(0, 0, 1, 1)
			boardAlreadyRendered = true
		}

		let xa = new Uint32Array(1)
		let xb = new Uint8Array(xa.buffer)

		function set(x, y, b) {
			board[x % canvas.width + (y % canvas.height) * canvas.width] = b
			xa[0] = PALETTE[b]
			canvasCtx.fillStyle = "#" + (xb[0] < 16 ? "0" : "") + xb[0].toString(16) + (xb[1] < 16 ? "0" : "") + xb[1].toString(16) + (xb[2] < 16 ? "0" : "") + xb[2].toString(16) + (xb[3] < 16 ? "0" : "") + xb[3].toString(16)
			canvasCtx.clearRect(x, y, 1, 1)
			canvasCtx.fillRect(x, y, 1, 1)
		}

		maincontent.addEventListener("touchmove", function(e) {
			for (let touch of e.changedTouches) {
				clearInterval(anim)
				// Single touch move
				if (!touch2 && touch1 && touch1.identifier == touch.identifier) {
					touchmoved -= Math.abs(touch.clientY - touch1.clientY) + Math.abs(touch.clientX - touch1.clientX)
					if (e.target != maincontent && !canvparent2.contains(e.target)) break
					x -= (touch.clientX - touch1.clientX) / (z * 50)
					y -= (touch.clientY - touch1.clientY) / (z * 50)
					pos()
				}
				// Multi-touch move
				else if (touch1 && touch2) {
					if (e.target != maincontent && !canvparent2.contains(e.target)) break
					let currentTouch = touch1.identifier == touch.identifier ? touch1 : (touch2.identifier == touch.identifier ? touch2 : null)
					if (!currentTouch) break
					let otherTouch = currentTouch == touch1 ? touch2 : touch1
					x -= (touch.clientX - currentTouch.clientX) / (z * 50)
					y -= (touch.clientY - currentTouch.clientY) / (z * 50)
					touchmoved -= Math.abs(touch.clientY - currentTouch.clientY) + Math.abs(touch.clientX - currentTouch.clientX)
					let dx = currentTouch.clientX - otherTouch.clientX
					let dy = currentTouch.clientY - otherTouch.clientY
					let initialDistance = dx * dx + dy * dy
					dx = touch.clientX - otherTouch.clientX
					dy = touch.clientY - otherTouch.clientY
					let scale = Math.sqrt((dx * dx + dy * dy) / initialDistance)
					z *= scale
					pos()
				}
				// Update touch points
				if (touch1 && touch1.identifier == touch.identifier) touch1 = touch
				else if (touch2 && touch2.identifier == touch.identifier) touch2 = touch
			}
		})

		// Blank default render and canvas size init before we have loaded board
		setSize(WIDTH, HEIGHT)
		renderAll()
		let anim = null

		function clicked(clientX, clientY) {
			clearInterval(anim)
			clientX = Math.floor(x + (clientX - innerWidth / 2) / z / 50) + 0.5
			clientY = Math.floor(y + (clientY - maincontent.offsetHeight / 2) / z / 50) + 0.5
			if (clientX == Math.floor(x) + 0.5 && clientY == Math.floor(y) + 0.5) {
				clientX -= 0.5;
				clientY -= 0.5
				if (CD < Date.now()) {
					zoomIn()
					showPalette()
				} else {
					AUDIOS.invalid.run()
				}
				return
			}
			(CD > Date.now() ? AUDIOS.invalid : AUDIOS.highlight).run()
			anim = setInterval(function() {
				x += (clientX - x) / 10
				y += (clientY - y) / 10
				pos()
				if (Math.abs(clientX - x) + Math.abs(clientY - y) < 0.1) clearInterval(anim)
			}, 15)
		}

		function zoomIn() {
			if (z >= 0.4) return
			clearInterval(anim)
			let dz = 0.005
			anim = setInterval(function() {
				if (dz < 0.2) dz *= 1.1
				z *= 1 + dz
				pos()
				if (z >= 0.4) clearInterval(anim)
			}, 15)
		}

		HTMLAudioElement.prototype.run = Audio.prototype.run = async function() {
			if (muted) return
			this.currentTime = 0
			this.play().catch(e => e)
		}

		// Necessary because of rolling updates
		if (!localStorage.muted !== "true") { // Prefer false
			localStorage.muted = "false"
		}
		if (!localStorage.placeChat !== "false") { // Prefer true
			localStorage.placeChat = "true"
		}
		let muted = localStorage.muted === "true"
		let placeChat = localStorage.placeChat === "true"
		let onCooldown = false
		let PEN = -1
		let CD = null
		let initialConnect = false

		mutesvg.innerHTML = muted ? MUTED_SVG : UNMUTED_SVG
		placeChatButton.children[0].style.opacity = placeChat ? '1' : '0.6'

		setInterval(async () => {
			let left = Math.floor((CD - Date.now()) / 1000)
			place.innerHTML = initialConnect
				? CD === null // They have made initial connect
					? `<span style="color:#f50; white-space: nowrap;">${await translate("connectingFail")}</span>` // They connected but now have disconnected
					: left > 0
						? `<svg xmlns="http://www.w3.org/2000/svg" data-name="icons final" viewBox="0 0 20 20" style="height: 1.1rem;vertical-align:top"><path d="M13.558 14.442l-4.183-4.183V4h1.25v5.741l3.817 3.817-.884.884z"></path><path d="M10 19.625A9.625 9.625 0 1119.625 10 9.636 9.636 0 0110 19.625zm0-18A8.375 8.375 0 1018.375 10 8.384 8.384 0 0010 1.625z"></path></svg> ${
								("" + Math.floor(left/3600)).padStart(2, "0")}:${("" + Math.floor((left / 60)) % 60).padStart(2, "0")}:${("" + left % 60).padStart(2, "0")}` // They are connected + still connected but in cooldown
						: await translate("placeTile") // They are connected + still connected + after cooldown
				: await translate("connecting") // They are yet to connect

			if (CD > Date.now() && !onCooldown) {
				onCooldown = true
			}
			if (CD < Date.now() && onCooldown) {
				onCooldown = false
				if (!document.hasFocus()) AUDIOS.cooldownEnd.run()
			}
		}, 200)

		function showPalette() {
			palette.style.transform = ""
			AUDIOS.highlight.run()
		}

		function generatePalette() {
			colours.innerHTML = ""
			for (let i = PALETTE_USABLE_REGION.start; i < PALETTE_USABLE_REGION.end; i++) {
				const colour = PALETTE[i]
				const colourEl = document.createElement("div")
				colourEl.dataset.index = i
				colourEl.style.background = `rgba(${colour & 255},${(colour >> 8) & 255},${(colour >> 16) & 255}, 1)`
				if (colour == 0xffffffff) {
					colourEl.style.outline = "1px #ddd solid"
					colourEl.style.outlineOffset = "-1px"
				}
				const indicatorSpan = document.createElement("span")
				indicatorSpan.contentEditable = true
				indicatorSpan.onkeydown = function(event) {
					rebindIndicator(event, i)
				}
				colourEl.appendChild(indicatorSpan)
				colours.appendChild(colourEl)
			}
		}
		generatePalette()

		colours.onclick = (e) => {
			const clickedColour = e.target
			if (!clickedColour || !clickedColour.dataset.index) {
				return
			}
			const i = parseInt(clickedColour.dataset.index)
			if (Number.isNaN(i) || i < PALETTE_USABLE_REGION.start || i >= PALETTE_USABLE_REGION.end) {
				return
			}
			for (const colour of colours.children) {
				colour.classList.remove("sel")
			}
			PEN = i
			canvselect.style.background = e.target.style.background
			e.target.classList.add("sel")
			pok.classList.add("enabled")
			canvselect.children[0].style.display = "none"
			canvselect.style.outline = "8px white solid"
			canvselect.style.boxShadow = "0px 2px 4px 0px rgb(0 0 0 / 50%)"
			hideIndicators()
			AUDIOS.selectColour.run()
		}

		function runLengthChanges(data, buffer) {
			let i = 9,
			boardI = 0
			let w = data.getUint32(1), h = data.getUint32(5)
			if (w != WIDTH || h != HEIGHT) setSize(w, h)
			board = new Uint8Array(buffer)
			while (i < data.byteLength) {
				let cell = data.getUint8(i++)
				let c = cell >> 6
				if (c == 1) c = data.getUint8(i++)
				else if (c == 2) c = data.getUint16(i++), i++
				else if (c == 3) c = data.getUint32(i++), i += 3
				boardI += c
				board[boardI++] = cell & 63
			}
			renderAll()
		}

		// The new server's equivalent for run length changes, based upon run length encoding
		function runLengthDecodeBoard(data, length) {
			data = new Uint8Array(data)
			board = new Uint8Array(length)
			let boardI = 0
			let colour = 0

			for (let i = 0; i < data.byteLength; i++) {
				// Then it is a palette value
				if (i % 2 == 0) {
					colour = data[i]
					continue
				}
				// After colour, loop until we unpack all repeats, byte can only hold max 255,
				// so we add one to repeated data[i], and treat it as if 0 = 1 (+1)
				for (let j = 0; j < data[i] + 1; j++) {
					board[boardI] = colour
					boardI++
				}
			}
			renderAll()
		}

		const encoder = new TextEncoder()
		const decoder = new TextDecoder()
		const allowed = ["rplace.tk", "rplace.live", "google.com", "wikipedia.org", "pxls.space"]
		const webGLSupported = (() => {
			let supported = true
			const glTestCanvas = document.createElement("canvas")
			try { supported = glTestCanvas.getContext("webgl2") !== null }
			catch(e) { supported = false }
			return supported
		})();
		if (!webGLSupported) {
			console.error("Client doesn't support WebGL! Some site features may break!")
		}
		const mobile = window.matchMedia("(orientation: portrait)").matches
		const hash = (text) => text.split("").reduce((hash, char) => (hash * 31 + char.charCodeAt()) >>> 0, 0)
		let online = 1
		let extraLanguage = (lang == "en" ? "tr" : lang)
		/** @type {Map<string, LiveChatMessage[]>} */ const cMessages = new Map([
			[extraLanguage, []],
			["en", []]
		])
		let chatPreviousLoadDebounce = false
		let chatPreviousAutoLoad = false
		let currentChannel = lang
		let fetchCooldown = 500, fetchFailTimeout = -1
		extraChannel(extraLanguage)
		initChannelDrop()
		switchLanguageChannel(currentChannel)
		wscapsule()

		async function fetchBoard() {
			// Override browser cache with ?v= param, may incurr longer loading times
			// TODO: investigate optimisations to onl;y do a hard realod when necessary
			const response = await fetch((localStorage.board || DEFAULT_BOARD) + "?v=" + Date.now())
			if (!response.ok) {
				showLoadingScreen()
				fetchFailTimeout = setTimeout(fetchBoard, fetchCooldown *= 2)
				if (fetchCooldown > 8000) {
					loadingScreen.children[0].src = "images/rplace-offline.png"
					clearTimeout(fetchFailTimeout)
				}

				return null
			}

			if (fetchFailTimeout != -1) clearTimeout(fetchFailTimeout)
			return await response.arrayBuffer()
		}

		// We don't await this yet, when the changes (old server) / canvas width & height (new server) packet
		// comes through, it will await this unawaited state until it is fufilled, so we are sure we have all the data
		let preloadedBoard = fetchBoard()

		function seti(i, b) {
			board[i] = b
			xa[0] = PALETTE[b]
			canvasCtx.fillStyle = "#" + (xb[0] < 16 ? "0" : "") + xb[0].toString(16) + (xb[1] < 16 ? "0" : "") + xb[1].toString(16) + (xb[2] < 16 ? "0" : "") + xb[2].toString(16) + (xb[3] < 16 ? "0" : "") + xb[3].toString(16)
			canvasCtx.fillRect(i % WIDTH, Math.floor(i / WIDTH), 1, 1)
		}

		function hideIndicators() {
			for (let c = 0; c < colours.children.length; c++) {
				colours.children[c].firstChild.style.visibility = "hidden"
			}
		}

		function rebindIndicator(e, i) {
			if (!e.key || e.key.length != 1) return
			e.target.innerText = e.key
			e.target.blur()

			let binds = (localStorage.paletteKeys || DEFAULT_PALETTE_KEYS).split("")
			let preexisting = binds.indexOf(e.key)
			if (preexisting != -1) binds[preexisting] = "â€‹"
			binds[i] = e.key.charAt(0)
			localStorage.paletteKeys = binds.join("")
			generateIndicators(binds.join(""))
		}
		function generateIndicators(keybinds) {
			for (let c = 0; c < colours.children.length; c++) {
				let indicator = colours.children[c].firstChild
				indicator.textContent = keybinds?.charAt(c)
			}
		}
		generateIndicators(localStorage.paletteKeys || DEFAULT_PALETTE_KEYS)

		if (chatName) {
			namePanel.style.visibility = "hidden"
		}

		function initChannelDrop() {
			let containsMy = false

			channelDrop.children[0].innerHTML = ""
			for (let [code, info] of LANG_INFOS) {
				if (code == lang) containsMy = true
				let el = document.createElement("li")
				el.innerHTML = `<span>${info.name}</span> <img src="${info.flag}" style="height: 24px;">`
				el["lang"] = code
				channelDrop.children[0].appendChild(el)
			}

			if (!containsMy) {
				let el = document.createElement("li")
				el.innerHTML = `<span>${lang}</span>`
				el["lang"] = lang
				channelDrop.children[0].appendChild(el)
			}
		}

		function extraChannel(code) {
			let info = LANG_INFOS.get(code)
			channelMineName.innerText = code.toUpperCase()
			channelMineImg.src = info?.flag
			channelMineImg.style.display = ((info?.flag) ? "inline" : "none")
			extraLanguage = code
			cMessages.set(code, cMessages.get(code) || [])
		}

		function switchLanguageChannel(selected) {
			channelMine.style.opacity = "0.5"
			channelEn.style.opacity = "0.5"
			if (currentChannel != selected) {
				chatCancelReplies()
			}
			currentChannel = selected
			chatMessages.style.direction = (LANG_INFOS.get(selected)?.rtl) ? "rtl" : "ltr"

			if (selected == "en") {
				channelEn.style.opacity = "1"
			}
			else if (selected == extraLanguage) {
				channelMine.style.opacity = "1"
			}
			chatMessages.innerHTML = ""
			// User must ask to load previous at least once for each channel before site
			// will start auto loading previous chat messages
			chatPreviousAutoLoad = false
			const messageRenderPromises = []

			if (cMessages.get(selected)?.length) {
				for (const messageEl of cMessages.get(selected)) {
					messageRenderPromises.push(messageEl.updateComplete)
					chatMessages.appendChild(messageEl)
				}
				Promise.all(messageRenderPromises).then(() => {
					chatMessages.scrollTo(0, chatMessages.scrollHeight)
				})
			}
			else if (typeof requestLoadChannelPrevious === "function") {
				// If we don't have any cached messages for this channel, try pre-populate with a few
				requestLoadChannelPrevious(32)
			}
		}

		/* @return {Element | HTMLCollection} */
		function stringToHtml(html, trim = true) {
			const template = document.createElement("template")
			template.innerHTML = html
			const result = template.content.children
			return result.length === 1 ? result[0] : result
		}

		function chatMentionUser(senderId) {
			const [ start, end ] = [ messageInput.selectionStart, messageInput.selectionEnd ]
			let mentionText = "@"
			const identifier = intIdNames.get(senderId) || ("#" + senderId)
			if (typeof identifier === "string") {
				mentionText += identifier
			}
			else if (typeof identifier === "number") {
				mentionText += "#" + identifier
			}
			messageInput.setRangeText(mentionText, start, end, "end")
			messageInput.focus()
		}

		async function chatReply(messageId, senderId) {
			for (let m of cMessages.get(currentChannel)) {
				m.removeAttribute("reply")
			}
			currentReply = messageId

			// HACK: Ensure no overlap between reply and send features
			messageTypePanel.style.height = "calc(var(--message-input-height) + 92px)"
			messageInput.focus()
			messageReplyPanel.removeAttribute("closed")
			messageReplyLabel.innerText = await translate("replyTo") + ": " + (intIdNames.get(senderId) || ("#" + senderId))
			for (let m of cMessages.get(currentChannel)) {
				if (m["messageId"] == messageId) {
					m.setAttribute("reply", "true")
					break
				}
			}
		}

		function chatCancelReplies() {
			for (let m of cMessages.get(currentChannel)) {
				m.removeAttribute("reply")
			}
			currentReply = null
			// HACK: Ensure no overlap between reply and send features
			messageTypePanel.style.height = "calc(var(--message-input-height) + 62px)"
			messageReplyPanel.setAttribute('closed', 'true')
		}

		function clearChatModerate() {
			modMessageId.value = ""
			modMessagePreview.innerHTML = ""
			modDurationH.value = null
			modDurationM.value = null
			modDurationS.value = null
			modAffectsAll.checked = false
			modReason.value = ""
		}

		function closeChatModerate() {
			moderationMenu.removeAttribute('opened')
			clearChatModerate()
		}

		// Mode: string ("delete"|"kick"|"mute"|"ban"|"captcha")
		function chatModerate(mode, senderId, messageId = null, messageElement = null) {
			clearChatModerate()
			modMemberId.value = senderId
			modMessageId.value = messageId
			moderationMenu.setAttribute("opened", "true")
			moderationMenu.setAttribute("mode", mode)
			modMessagePreview.innerHTML = messageElement?.innerHTML

			switch(mode) {
				case "delete":
					modActionDelete.checked = true
					break
				case "kick":
					modActionKick.checked = true
					break
				case "mute":
					modActionMute.checked = true
					break
				case "ban":
					modActionBan.checked = true
					break
				case "captcha":
					modActionCaptcha.checked = true
					break
			}
		}

		function closeMessageEmojisPanel() {
			messageEmojisPanel.setAttribute("closed", "true")
			messageInput.setAttribute("state", "default")
		}

		let messageInputHeight = messageInput.scrollHeight
		function updateMessageInputHeight() {
			messageInput.style.height = "0px"
			const oldHeight = messageInputHeight
			messageInputHeight = Math.min(messageInput.scrollHeight, 256)
			chatPanel.style.setProperty("--message-input-height", messageInputHeight + "px")
			messageInput.style.height = "" // unset
			const diffHeight = messageInputHeight - oldHeight
			chatMessages.scrollBy(0, diffHeight)
		}

		messageInput.oninput = e => {
			if (!e.isTrusted) return
			updateMessageInputHeight()

			messageEmojisPanel.innerHTML = ""
			let comp = ""
			let search = true
			let count = 0
			for (let i = messageInput.value.length - 1; i >= 0; i--) {
				// No emoji code will ever have a space before we reach the opening : (going backwards
				// through string) so we can guess to just stop if seen as we backtrack
				if (messageInput.value[i] == " " && search) {
					comp = ""
					break
				}
				else if (messageInput.value[i] == ":") {
					count++
					search = false
				}
				if (search) {
					comp = messageInput.value[i] + comp
				}
			}
			//All : already closed, they are probably not trying to do an emoji so we ignore
			if (count % 2 == 0) comp = ""

			if (comp) {
				messageInput.setAttribute("state", "command")
			}
			else {
				closeMessageEmojisPanel()
			}

			function createEmojiEntry(emojiCode) {
				const entryElement = document.createElement("button")
				entryElement.classList.add("message-emojis-suggestion")
				entryElement.title = `Send this emoji in chat with :${emojiCode}:`
				const entryLabel = document.createElement("span")
				entryLabel.textContent = `:${emojiCode}:`
				entryElement.appendChild(entryLabel)
				return entryElement
			}

			let handled = false
			for (const [emojiCode, value] of EMOJIS) {
				if (comp && emojiCode.startsWith(comp)) {
					const entryElement = createEmojiEntry(emojiCode)
					const entryValueText = document.createTextNode(value)
					entryElement.appendChild(entryValueText)
					entryElement.addEventListener("click", function() {
						for (let i = messageInput.value.length - 1; i >= 0; i--) {
							if (messageInput.value[i] == ":") {
								messageInput.value = messageInput.value.slice(0, i) + value
								closeMessageEmojisPanel()
								break
							}
						}
					})
					messageEmojisPanel.appendChild(entryElement)
					messageEmojisPanel.removeAttribute("closed")
				}

				if (messageInput.value.includes(":" + emojiCode + ":")) {
					messageInput.value = messageInput.value.replace(":" + emojiCode + ":", value)
					messageInput.setAttribute("state", "default")
					handled = true
				}
			}
			if (!handled) for (const [emojiCode, value] of CUSTOM_EMOJIS) {
				if (comp && emojiCode.startsWith(comp)) {
					const entryElement = createEmojiEntry(emojiCode)
					entryElement.appendChild(stringToHtml(value))
					entryElement.addEventListener("click", function() {
						for (let i = messageInput.value.length - 1; i >= 0; i--) {
							if (messageInput.value[i] == ":") {
								messageInput.value = messageInput.value.slice(0, i) + ":" + emojiCode + ":"
								closeMessageEmojisPanel()
								break
							}
						}
					})
					messageEmojisPanel.appendChild(entryElement)
					messageEmojisPanel.removeAttribute("closed")
				}

				if (messageInput.value.includes(":" + emojiCode + ":")) {
					messageInput.setAttribute("state", "default")
					handled = true
				}
			}
			if (!handled) for (const [commandCode, value] of COMMANDS) {
				if (comp && commandCode.startsWith(comp)) {
					const entryElement = document.createElement("button")
					entryElement.classList.add("message-emojis-suggestion")
					entryElement.title = `Use this command in chat :${commandCode} [ARGUMENTS]`
					const entryLabel = document.createElement("span")
					entryLabel.textContent = `:${commandCode}`
					entryElement.appendChild(entryLabel)
					entryElement.addEventListener("click", function() {
						messageInput.value = ":" + commandCode
						closeMessageEmojisPanel()
					})
					entryElement.appendChild(stringToHtml(value))
					messageEmojisPanel.appendChild(entryElement)
					messageEmojisPanel.removeAttribute("closed")
				}

				if (messageInput.value.includes(":" + commandCode)) {
					messageInput.setAttribute("state", "default")
					handled = true
				}
			}
		}

		function switchGameServer(serverAddress) {
			if (serverAddress) {
				let [a, b] = serverAddress.split(" ").reverse()
				if (!b)[b, a] = [a + '/place', 'server.' + a]
				a = "wss://" + a
				b = "https://" + b
				server(a, b)
			}
			else {
				delete localStorage.board
				delete localStorage.server
			}
			let queries = location.toString().split('?')
			if (queries.length > 1)
				location.replace(location.toString().split('?')[0], false)
			else
				location += ""
		}

		function server(serverAddress, boardAddress, vip = "", storage = localStorage) {
			if (!serverAddress) {
				storage.vip = storage.vip2
				delete storage.vip2
				delete storage.server
				delete storage.board
				return
			}

			storage.vip2 = storage.vip2 || storage.vip
			storage.vip = vip
			storage.server = serverAddress
			storage.board = boardAddress
		}

		async function forceTheme(forceTheme, forceVariant = null , effects = null) {
			const currentThemeSet = document.documentElement.dataset.theme
			const currentVariant = document.documentElement.dataset.variant
			if (currentThemeSet != forceTheme || currentVariant != forceVariant) {
				console.warn("Forcing site theme to", forceTheme, forceVariant)
				await theme(DEFAULT_THEMES.get(forceTheme), forceVariant, effects)
			}
		}

		let styleElement = null
		let currentTheme = null
		async function theme(themeSet, variant = null, effects = null) {
			variant ??= ""

			// Effects
			disableDarkplace()
			disableWinter()
			switch (effects) {
				case "darkplace":
					enableDarkplace()
					break
				case "winter":
					enableWinter()
					break
			}

			if (currentTheme !== themeSet) {
				// Intermediate stylesheet handles giving a nice transition animation during theme change
				const intermediate = document.createElement("link")
				intermediate.rel = "stylesheet"
				intermediate.type = "text/css"
				intermediate.href = "theme-switch.css"
				intermediate.setAttribute("intermediate-temp", "true")
				await (new Promise(resolve => {
					intermediate.onload = resolve
					document.head.appendChild(intermediate)
				}))
				// Load in new CSS
				const link = document.createElement("link")
				link.rel = "stylesheet"
				link.type = "text/css"
				link.href = themeSet.css + "?v=" + themeSet.cssVersion
				await (new Promise(async (resolve) => {
					link.onload = resolve
					document.head.appendChild(link)
				}))
				setTimeout(() => document.head.removeChild(intermediate), 200)
				// Swap out intermediate and old stylesheet
				if (styleElement) document.head.removeChild(styleElement)
				styleElement = link
				currentTheme = themeSet

				document.querySelectorAll("[theme]").forEach((element) => {
					if (element.tagName == "IMG") {
						element.src = themeSet[element.getAttribute("theme")] || element.src
					}
					else {
						element.innerHTML = themeSet[element.getAttribute("theme")] || element.innerHTML
					}
				})
				document.documentElement.dataset.theme = themeSet.id
			}
			document.documentElement.dataset.variant = variant
		}
		const startupThemeSet = DEFAULT_THEMES.get(localStorage.theme || "r/place 2022")
		// TEMP: Christmas / new years 2024
		theme(DEFAULT_THEMES.get("r/place 2022"), "merry", "winter")
		//theme(startupThemeSet, localStorage.variant, localStorage.effects)
		themeDropName.textContent = "ğŸ–Œï¸ " + (localStorage.theme || "r/place 2022")

		// Apply all translations from shared.js
		translateAll()
		function clamp(num, min, max) {
			return Math.min(Math.max(num, min), max)
		}

		function tlMouseMove(e) {
			if (!tlSelect.getAttribute('dragging') == "true") {
				tlSelect.style.cursor = "default"
				return
			}
			tlSelect.style.left = clamp(e.clientX - tlImage.getBoundingClientRect().left, 0, WIDTH - tlSelect.style.width) + "px"
			tlSelect.style.top = clamp(e.clientY - tlImage.getBoundingClientRect().top, 0, HEIGHT - tlSelect.style.height) + "px"
			tlSelect.style.cursor = "all-scroll"
		}

		function toggleTlPanel() {
			timelapsePanel.style.display = timelapsePanel.style.display == 'none' ? 'block' : 'none'
			tlImage.src = canvas.toDataURL("image/png")
			tlSelect.style.width = WIDTH + "px"
			tlSelect.style.height = HEIGHT + "px"

			let backups = []
			fetch(localStorage.board + '/backuplist')
				.then((response) => response.text())
				.then((data) => {
					for (let b of data.split("\n")) backups.push(b)
				})
		}

		let tlTimerStart
		function confirmTlCreate() {
			tlConfirm.value = "Timelapse loading. Hang tight! â³"
			tlConfirm.style.pointerEvents = "none"
			tlTimerStart = Date.now()
			let tlTimerInterval = setInterval(updateTlTimer, 100)

			fetch(`https://${localStorage.server || DEFAULT_SERVER}/timelapse/`, {
					method: "POST",
					body: JSON.stringify({
						"backupStart": tlStartSel.value,
						"backupEnd": tlEndSel.value,
						"fps": Number(tlFps.value),
						"startX": 0,
						"startY": 0,
						"endX": WIDTH,
						"endY": HEIGHT,
						"reverse": tlPlayDir.getAttribute('reverse') == "true"
					}),
					headers: { 'Content-type': 'application/json; charset=UTF-8' }
				})
				.then(resp => resp.blob())
				.then(blob => {
					const url = window.URL.createObjectURL(blob)
					const a = document.createElement('a')
					a.style.display = 'none'
					a.href = url
					a.download = 'place_timelapse.gif'
					document.body.appendChild(a)
					a.click()
					tlConfirm.value = "Create"
					tlConfirm.style.pointerEvents = "auto"
					clearInterval(tlTimerInterval)
					tlTimer.innerText = "0.0s"
				})
				.catch((e) => {
					console.error("Timelapse failed, " + e)
					tlConfirm.value = "Create"
					tlConfirm.style.pointerEvents = "auto"
					clearInterval(tlTimerInterval)
					tlTimer.innerText = "0.0s"
				})
		}

		function updateTlTimer() {
			let elapsedTime = Date.now() - tlTimerStart
			document.getElementById("tlTimer").innerText = ((elapsedTime / 1000).toFixed(3)) + "s"
		}

		var overlayInfo = { x: 0, y: 0, w: 0, h: 0, opacity: 0.8, type: "" }
		overlayInput.onchange = function() {
			if (!overlayInput.files || !overlayInput.files[0]) return
			templateImage.src = URL.createObjectURL(overlayInput.files[0])
			templateImage.style.opacity = 0.8
		}
		async function generateOverlayUrl() {
			overlayInfo["type"] = overlayInput.files[0].type
			overlayInfo["data"] = btoa(String.fromCharCode(...new Uint8Array(await overlayInput.files[0].arrayBuffer())))
			return `${location.origin}/?server=${localStorage.server || DEFAULT_SERVER}&board=${localStorage.board || DEFAULT_BOARD}&overlay=${btoa(JSON.stringify(overlayInfo))}`
		}

		let blockedUsers = localStorage.blocked?.split(",") || []
		let targetedIntId = null
		let targetedMsgId = null
		let currentReply = null
		let openedChat = false

		function openChatPanel() {
			chatPanel.setAttribute("open", "true")
			if (!openedChat) {
				;(adsbygoogle = window.adsbygoogle || []).push({});
				openedChat = true
			}
			chatPanel.inert = false
		}

		function closeChatPanel() {
			messageInput.blur()
			chatPanel.removeAttribute("open")
			chatPanel.inert = true
		}
		closeChatPanel()

		async function onChatContext(e, senderId, msgId) {
			e.preventDefault()

			if (chatContext.style.display == "block") {
				chatContext.style.display = "none"
			}
			else {
				let msgName = intIdNames.get(senderId)
				const identifier = msgName || ("#" + senderId)
				if (msgName) {
					if (msgName[msgName.length - 1] === "~") {
						msgName = msgName.slice(0, -1)
						userNote.style.display = "block"
						userNote.textContent = "This user is likely impersonating @" + msgName
					}
					else if (msgName[msgName.length - 1] === "âœ“") {
						msgName = msgName.slice(0, -1)
						userNote.style.display = "block"
						userNote.textContent = "This user is verified as @" + msgName
					}
					else {
						userNote.style.display = "none"
					}
				}

				targetedMsgId = msgId
				targetedIntId = senderId
				chatContext.style.display = "block"
				mentionUser.children[0].textContent = `${await translate("mention")} ${identifier}`
				replyUser.children[0].textContent = `${await translate("replyTo")} ${identifier}`
				blockUser.children[0].textContent =
					`${await translate(blockedUsers.includes(senderId) ? "unblock" : "block")} ${identifier}`

				if (senderId == intId) {
					blockUser.style.pointerEvents = "none"
					blockUser.children[0].style.color = "grey"
					changeMyName.style.display = ""
				}
				else  {
					blockUser.style.pointerEvents = "all"
					blockUser.children[0].style.color = "black"
					changeMyName.style.display = "none"
				}

				chatContext.style.left = e.pageX - chatPanel.offsetLeft + "px"
				chatContext.style.top = e.pageY - chatPanel.offsetTop + "px"
			}
		}

		const verifiedAppHash = "f255e4c294a5413cce887407b91062ac162faec4cb1e6e21cdd6e4492fb270f8"
		async function checkVerifiedAppStatus() {
			const urlParams = new URLSearchParams(window.location.search);
			const verifyAppValue = urlParams.get("verify-app")
			if (!verifyAppValue) {
				return "none"
			}
			const hashedValue = await sha256(verifyAppValue)
			return hashedValue === verifiedAppHash ?  "valid" : "invalid"
		}
		function sha256(str) {
			const encoder = new TextEncoder()
			const data = encoder.encode(str)
			return crypto.subtle.digest("SHA-256", data).then(hashBuffer => {
				const hashArray = Array.from(new Uint8Array(hashBuffer))
				return hashArray.map(byte => byte.toString(16).padStart(2, "0")).join("")
			})
		}
		checkVerifiedAppStatus().then(status => {
			if (status === "valid") {
				console.log("Successfully verified rplace.live app");
			}
			else {
				if (window.location !== window.parent.location
						|| typeof window.Android !== "undefined"
						|| typeof window.Kodular !== "undefined"
						|| status == "invalid") {
					window.location.replace("fakeapp.html")
					// Block interaction if page redirect was overidden
					document.body.style.opacity = "0.6"
					document.body.style.pointerEvents = "none"
					alert("Error: App failed verification - game is being accessed via an unofficial or unauthorised site or app\n" +
						"Please report to developers or visit the game online at https://rplace.live")
				}
			}
		})

		// Prompt user if they want to install site as PWA if they press the modal button
		let pwaPrompter = null
		window.addEventListener("beforeinstallprompt", function(e) {
			e.preventDefault()
			pwaPrompter = e
		})
		window.addEventListener("contextmenu", function(e) {
			e.preventDefault()
		})

		// Cancel touchpad page zooming that interferes with canvas zooming
		if (!mobile) {
			function cancelZoomGesture(e) {
				e.preventDefault()
			}
			window.addEventListener("wheel", function(e) {
				if (e.target == maincontent || canvparent2.contains(e.target)) {
					e.preventDefault()
				}
			}, { passive: false })
			window.addEventListener("gesturestart", cancelZoomGesture)
			window.addEventListener("gesturechange", cancelZoomGesture)
			window.addEventListener("gestureend", cancelZoomGesture)
		}

		setTimeout(() => {
			if (window.connproblems) {
				connproblems.style.opacity = 1
			}
		}, 5000)

		// Ads
		if (localStorage.noad && Date.now() - localStorage.noad < 1.21e9) { // 14 days
			chatAd.style.display = "none"
		}
		else {
			let adI = Math.floor(Math.random() * ADS.length)
			function cycleAd() {
				const currentAd = ADS[adI % ADS.length]
				chatAd.style.setProperty("--adurl", `url(${currentAd.banners[lang] || currentAd.banners["en"]})`)
				chatAd.href = currentAd.url
				adI++
			}
			setInterval(cycleAd, 12e4) // 2 mins
			cycleAd()
		}

		window.moduleExports = {
			...window.moduleExports,
			get x() {
				return x
			},
			set x(value) {
				x = value
			},
			get y() {
				return y
			},
			set y(value) {
				y = value
			},
			get pos() {
				return pos
			},
			get chatMentionUser() {
				return chatMentionUser	
			},
			get onChatContext() {
				return onChatContext
			},
			get chatReact() {
				return chatReact
			},
			get chatReply() {
				return chatReply
			},
			get chatReport() {
				return chatReport
			},
			get chatModerate() {
				return chatModerate
			},
			get CHAT_COLOURS() {
				return CHAT_COLOURS
			},
			get hash() {
				return hash
			},
			get cMessages() {
				return cMessages
			},
			get chatMessages() { // element
				return chatMessages
			},
			get currentChannel() {
				return currentChannel
			},
			get EMOJIS() {
				return EMOJIS
			},
			get CUSTOM_EMOJIS() {
				return CUSTOM_EMOJIS
			},
			get intIdNames() {
				return intIdNames
			},
			get chatReactionsPanel() {
				return chatReactionsPanel
			}
		}
	</script>
</html>
